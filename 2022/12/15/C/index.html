<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++ | Valerian's Blog</title><meta name="keywords" content="C++"><meta name="author" content="Valerian"><meta name="copyright" content="Valerian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="C++程序设计面向对象的三大特点 类和对象###封装 class Circle&amp;#123;  &#x2F;&#x2F;访问权限  &#x2F;&#x2F;公共权限  public:    &#x2F;&#x2F;类中的属性和行为 我们统一称为 成员  &#x2F;&#x2F;行为 成员函数 成员方法  &#x2F;&#x2F;属性 成员属性 成员变量  int m_r; &#x2F;&#x2F; 半径    &#x2F;&#x2F;行为  &#x2F;&#x2F;获取圆的周长  double caculateZC()&amp;#123;    return 2">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="http://example.com/2022/12/15/C/index.html">
<meta property="og:site_name" content="Valerian&#39;s Blog">
<meta property="og:description" content="C++程序设计面向对象的三大特点 类和对象###封装 class Circle&amp;#123;  &#x2F;&#x2F;访问权限  &#x2F;&#x2F;公共权限  public:    &#x2F;&#x2F;类中的属性和行为 我们统一称为 成员  &#x2F;&#x2F;行为 成员函数 成员方法  &#x2F;&#x2F;属性 成员属性 成员变量  int m_r; &#x2F;&#x2F; 半径    &#x2F;&#x2F;行为  &#x2F;&#x2F;获取圆的周长  double caculateZC()&amp;#123;    return 2">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/cover2.png">
<meta property="article:published_time" content="2022-12-15T13:09:45.000Z">
<meta property="article:modified_time" content="2022-12-15T13:10:59.026Z">
<meta property="article:author" content="Valerian">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/12/15/C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-15 21:10:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/footer.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/tagnum.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/categoryBar/categoryBar.css"><link rel="stylesheet" type="text/css" href="https://blog.eurkon.com/css/custom.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/404/404.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Valerian's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-12-15T13:09:45.000Z" title="Created 2022-12-15 21:09:45">2022-12-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-12-15T13:10:59.026Z" title="Updated 2022-12-15 21:10:59">2022-12-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">43.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>181min</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-程序设计"><a href="#C-程序设计" class="headerlink" title="C++程序设计"></a>C++程序设计</h1><p>面向对象的三大特点</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>###封装</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">  <span class="comment">//访问权限</span></span><br><span class="line">  <span class="comment">//公共权限</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//类中的属性和行为 我们统一称为 成员</span></span><br><span class="line">  <span class="comment">//行为 成员函数 成员方法</span></span><br><span class="line">  <span class="comment">//属性 成员属性 成员变量</span></span><br><span class="line">  <span class="type">int</span> m_r; <span class="comment">// 半径</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//行为</span></span><br><span class="line">  <span class="comment">//获取圆的周长</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">caculateZC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * PI * m_r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//通过圆类 创建具体的圆</span></span><br><span class="line">  <span class="comment">//实例化 通过一个类创建一个对象</span></span><br><span class="line">  Circle c1;</span><br><span class="line">  <span class="comment">//给对象的属性进行赋值</span></span><br><span class="line">  c1.m_r = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;圆的周长为：&quot;</span> &lt;&lt; c1.caculateZc &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="type">int</span> m_Id;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; m_Name &lt;&lt; m_Id &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">    m_Name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(string id)</span></span>&#123;</span><br><span class="line">    m_Id = id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Student s1;</span><br><span class="line">  s1.m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">  s1.m_Id = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  s1.<span class="built_in">showStudent</span>();</span><br><span class="line">  s1.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  s1.<span class="built_in">setId</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####封装的意义</p>
<ul>
<li>public 公共权限  成员 类内可以访问 类外可以访问</li>
<li>protected 保护权限 成员 类内可以访问 类外不可以访问  儿子也可以访问父亲中的保护内容 儿子不可以访问父亲的私有内容</li>
<li>private 私有权限 成员 类内可以访问 类外不可以访问</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_Name;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  string m_Car;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m_Name = <span class="string">&quot;张三&quot;</span>；</span><br><span class="line">    m_Car = <span class="string">&quot;拖拉机&quot;</span>；</span><br><span class="line">    m_Password = <span class="number">123456</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p1;</span><br><span class="line">  p1.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"> <span class="comment">//p1.m_Car = &quot;奔驰&quot;;</span></span><br><span class="line"> <span class="comment">//p1.m_Password = 123456;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>struct 和 class 唯一的区别就在于默认的访问权限不同 struct 默认权限为公共 class 默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>&#123;</span><br><span class="line">  <span class="type">int</span> m_A; <span class="comment">//默认权限 是私有</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span>&#123;</span><br><span class="line">  <span class="type">int</span> m_A; <span class="comment">//默认权限 是公共</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>成员属性设置为私有 可以自己控制读写权限 对于写可以检测数据的有效性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//设置姓名</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">    m_Name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取姓名</span></span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取年龄</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//m_Age = 0;</span></span><br><span class="line">    <span class="keyword">return</span> m_Age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">      m_Age = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置情人 只写</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span></span>&#123;</span><br><span class="line">    m_Lover = lover;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>;</span><br><span class="line">  <span class="comment">//姓名 可读可写</span></span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="comment">//年龄  只读</span></span><br><span class="line">  <span class="type">int</span> m_Age;</span><br><span class="line">  <span class="comment">//情人  只写</span></span><br><span class="line">  string m_Lover;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p;</span><br><span class="line">  <span class="comment">//p.m_Name = &quot;张三&quot;;</span></span><br><span class="line">  p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>)；</span><br><span class="line">  cout &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl; </span><br><span class="line">  cout &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">  p.<span class="built_in">setLover</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>案例练习</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>设计一个立方体类</span><br><span class="line">  </span><br><span class="line"><span class="comment">//利用全局函数判断 两个立方体是否相等</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(Cube &amp;c1,Cube &amp;c2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(c1.<span class="built_in">getL</span>()==c2.<span class="built_in">getL</span>() &amp;&amp; ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cube</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//行为</span></span><br><span class="line">  <span class="comment">//获取立方体面积</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">calculateS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*m_L*m_W+<span class="number">2</span>*m_L*m_H+<span class="number">2</span>*m_H*m_W;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取立方体体积</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">calculateV</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_L*m_W*m_H;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置获取长宽高</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setL</span><span class="params">(<span class="type">int</span> l)</span></span>&#123;</span><br><span class="line">    m_L = l;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getL</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_L</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//利用成员函数判断两个立方体是否相等</span></span><br><span class="line">  <span class="type">bool</span> <span class="built_in">isSameByClass</span>(Cube &amp;c)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_L == c.<span class="built_in">getL</span>() &amp;&amp; m_W == c.<span class="built_in">getW</span>() &amp;&amp;) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="type">int</span> m_L;</span><br><span class="line">  <span class="type">int</span> m_W;</span><br><span class="line">  <span class="type">int</span> m_H;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>点和圆的关系</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    m_X = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_X;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_X;</span><br><span class="line">  <span class="type">int</span> m_Y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setR</span><span class="params">(<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    m_R = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getR</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_R;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setCenter</span><span class="params">(Point center)</span></span>&#123;</span><br><span class="line">    m_Center = center;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Point <span class="title">getCenter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Center;</span><br><span class="line">  &#125;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_R;</span><br><span class="line">  <span class="comment">//在类中可以让另一个类作为本来的成员</span></span><br><span class="line">  Point m_Center;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isInCircle</span><span class="params">(Circle &amp;c,Point &amp;p)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> dis = (c.getCenter.<span class="built_in">getX</span>()-p.<span class="built_in">getX</span>()) * (c.getCenter.<span class="built_in">getX</span>()-p.<span class="built_in">getX</span>()) + </span><br><span class="line">  (c.getCenter.<span class="built_in">getY</span>()-p.<span class="built_in">getY</span>()) * (c.getCenter.<span class="built_in">getY</span>()-p.<span class="built_in">getY</span>())</span><br><span class="line">  <span class="type">int</span> rdis = c.<span class="built_in">getR</span>() * c.<span class="built_in">getR</span>();</span><br><span class="line">  <span class="keyword">if</span>(rdis == dis)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(dis &gt; rdis)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(dis &lt; rdis)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里还教学了如何将一个类拆分成多个文件</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
</ul>
<p>###对象的初始化和清理</p>
<h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><ul>
<li><p>对象的初始化和清理也是两个非常重要的安全问题</p>
</li>
<li><p>C++利用了构造函数和析构函数解决上述问题 这两个函数将会被编译器自动调用，完成对象的初始化和清理工作。对象的初始化和清理工作是编译器强制要求我们做的事情，因此如果我们不提供构造和析构，编译器会提供，但编译器提供的构造函数和析构函数是空实现的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">构造函数语法： 类名()&#123;&#125;</span><br><span class="line"><span class="number">1.</span>构造函数没有返回值</span><br><span class="line"><span class="number">2.</span>名称与类名相同</span><br><span class="line"><span class="number">3.</span>构造函数可以有参数，因此可以发生重载</span><br><span class="line"><span class="number">4.</span>程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次</span><br><span class="line"></span><br><span class="line">析构函数语法： ~类名()&#123;&#125;</span><br><span class="line"><span class="number">1.</span>在名称前面加上~</span><br><span class="line"><span class="number">2.</span>析构函数不可以有参数不会发生重载</span><br></pre></td></tr></table></figure></li>
<li><p>案例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p;<span class="comment">//在栈上的数据，test执行完毕之后 释放这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>####构造函数的分类和调用</p>
<ul>
<li>两种分类方式 按参数分为 有参构造和无参构造 按类型分为 普通构造和拷贝构造</li>
<li>三种调用方式 括号法 显示法 隐式转换法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person类的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person类的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//拷贝构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line">    <span class="comment">//将传入的人身上的所有属性拷贝</span></span><br><span class="line">    age = p.age;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person类的拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//括号法</span></span><br><span class="line">  Person p1;<span class="comment">//默认构造函数的调用  </span></span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//有参构造函数</span></span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span><span class="comment">//拷贝构造函数的调用</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">  <span class="comment">//注意事项：调用默认构造函数时候 不要加() 不会创建对象 因为编译器会认为这是一个函数的申明 一个函数里面可以写另一个函数的申明</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  <span class="comment">//显示法</span></span></span><br><span class="line"><span class="function">  Person p1</span>;</span><br><span class="line">  Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//有参构造</span></span><br><span class="line">  Person p3 = <span class="built_in">Person</span>(p2);<span class="comment">//拷贝构造</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//注意事项： 1.Person(10) 叫做匿名对象 特点:当前行结束后，系统会立即收回匿名对象 </span></span><br><span class="line">  <span class="comment">//         2.不要利用拷贝构造函数初始化匿名对象 编译器会认为 Person(p3) === Person p3;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//隐式转换法</span></span><br><span class="line">  Person p4 = <span class="number">10</span> <span class="comment">//相当于写了 Person p4 = Person(10);</span></span><br><span class="line">  Person p5 = p4;<span class="comment">//拷贝构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####拷贝构造函数调用时机</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Person有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m_Age = p.m_Age;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p;</span><br><span class="line">  <span class="built_in">doWork</span>(p); <span class="comment">//实参调用形参的时候拷贝出来临时的副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p1;</span><br><span class="line">  cout &lt;&lt; (<span class="type">int</span>*)&amp;p1 &lt;&lt; endl; </span><br><span class="line">  <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">  cout &lt;&lt; (<span class="type">int</span>*)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><p>默认情况下 c++编译器至少会给一个类添加三个函数</p>
<ol>
<li>默认构造函数 （空实现）</li>
<li>默认析构函数 (空实现)</li>
<li>默认拷贝构造函数 （值拷贝）</li>
</ol>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数 c++不再提供无参构造 但是会提供默认拷贝构造函数</li>
<li>如果用户定义有拷贝构造函数 c++不会再提供其它构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Person有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m_Age = p.m_Age;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p;</span><br><span class="line">  p.m_Age = <span class="number">18</span>;</span><br><span class="line">  </span><br><span class="line">  Person p2 = <span class="built_in">Person</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p;  <span class="comment">//如果只提供有参构造函数 这样写会报错 因为编译器不会提供默认构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><ul>
<li><p>浅拷贝：简单的赋值拷贝操作</p>
</li>
<li><p>深拷贝：在堆区重新申请空间 进行拷贝操作</p>
<p>如果属性有在堆区开辟的 一定要自己提供拷贝构造函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">int</span> ag,<span class="type">int</span> height)&#123;</span><br><span class="line">    m_Age = age;</span><br><span class="line">    m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//需要自己实现一个拷贝构造函数 解决浅拷贝带来的问题</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)&#123;</span><br><span class="line">    m_Age = p.m_Age;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m_Height = <span class="keyword">new</span> <span class="built_in">int</span> (*p.m_Height);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">    <span class="comment">//需要将堆区开辟的数据释放</span></span><br><span class="line">    <span class="keyword">if</span>(m_Height != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span> m_Height;</span><br><span class="line">      m_Height = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> m_Age;</span><br><span class="line">  <span class="type">int</span> *m_Height; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>,<span class="number">160</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;<span class="comment">// 浅拷贝带来的问题就是堆区的内存重复释放 浅拷贝的问题要利用深拷贝进行解决</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>作用：C+提供了初始化列表语法 用来初始化属性</p>
<p>语法：构造函数( ):属性( ),属性( )</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//传统初始化操作</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)&#123;</span><br><span class="line">    m_A = a;</span><br><span class="line">    m_B = b;</span><br><span class="line">    m_C = c;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//初始化列表初始化属性</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c):<span class="built_in">m_A</span>(a),<span class="built_in">m_B</span>(b),<span class="built_in">m_C</span>(c)&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> m_A;</span><br><span class="line">  <span class="type">int</span> m_B;</span><br><span class="line">  <span class="type">int</span> m_C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p;</span><br><span class="line">  <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><ul>
<li><p>C++类中的成员可以是另一个类的对象 我们称该成员为对象成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B类中有对象作为成员 A为对象成员</span><br><span class="line">那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</span><br></pre></td></tr></table></figure>

<ul>
<li>案列</li>
</ul>
<figure class="highlight c++"><figcaption><span>11</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Phone</span>(string pName)&#123;</span><br><span class="line">    m_PName = pName;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Phone的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Phone</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Phone类的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  string m_PName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Phone m_Phone = pName</span></span><br><span class="line">  <span class="built_in">Person</span>(string Name,string pName):<span class="built_in">m_Name</span>(Name),<span class="built_in">m_Phone</span>(pName)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person类的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;;</span><br><span class="line">  ～<span class="built_in">Person</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person类的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//姓名</span></span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="comment">//手机</span></span><br><span class="line">  Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当其他类对象作为本类成员 构造时候先构造类对象再构造自身，析构的顺序与构造相反</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;苹果MAX&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><ul>
<li>静态成员就是在成员变量和成员函数前加上关键字static 称为静态成员</li>
<li>静态成员分为<ol>
<li> 静态成员变量   所有对象共享同一份数据 在编译阶段分配内存 类内申明，类外初始化</li>
<li> 静态成员函数    所有对象共享同一个函数 静态成员函数只能访问静态成员变量</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//1所有对象都共享同一份数据</span></span><br><span class="line">  <span class="comment">//2编译阶段分配内存</span></span><br><span class="line">  <span class="comment">//3类内申明 类外初始化</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//类外不能访问</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p;</span><br><span class="line">  cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">  Person p2;</span><br><span class="line">  p2.m_A = <span class="number">200</span>;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; p.m_A &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//静态成员变量不属于某个对象上 所有对象都共享同一份数据</span></span><br><span class="line">  <span class="comment">//因此可以有两种访问方式</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//1通过对象进行访问</span></span><br><span class="line">  Person p;</span><br><span class="line">  cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2通过类名进行访问</span></span><br><span class="line">  cout &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m_A = <span class="number">100</span>;<span class="comment">//静态成员函数可以访问 静态成员变量</span></span><br><span class="line">    <span class="comment">//m_B = 200 静态成员函数不可以访问非静态成员变量 函数无法区分特定对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static void func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> m_A;<span class="comment">//静态成员变量</span></span><br><span class="line">  <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static void func2的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//通过对象访问</span></span><br><span class="line">  Person p;</span><br><span class="line">  p.<span class="built_in">func</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过类名访问</span></span><br><span class="line">  Person::<span class="built_in">func</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Person::func2();不可以访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-对象模型和this指针"><a href="#c-对象模型和this指针" class="headerlink" title="c++对象模型和this指针"></a>c++对象模型和this指针</h3><h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><p>在c++中 类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_A <span class="comment">//非静态成员变量 属于类的对象</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> m_B <span class="comment">//静态成员变量 不属于类对象上</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//非静态成员函数 不属于类的对象上</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//静态成员函数 不属于类的对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p;</span><br><span class="line">  <span class="comment">//空对象占用内存空间为：1</span></span><br><span class="line">  <span class="comment">//c++编译器会给每个空对象也分配一个字节空间 为了区分空对象占内存的位置</span></span><br><span class="line">  <span class="comment">//每个空对象也应该有一个独一无二 的内存地址</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Size of p = &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><ul>
<li><p>我们知道每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是 这一块代码是如何区分哪个对象调用自己的呢？</p>
</li>
<li><p>c++ 通过提供特殊的对象指针–this指针 this 指针指向<strong>被调用的成员函数所属的对象</strong></p>
</li>
<li><p>this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义 直接使用即可</p>
</li>
<li><p>this指针的用途：1.当形参和成员变量同名时可用this指针来区分 2.在类的非静态成员函数中返回对象本身 可以使用return *this</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="comment">//this 指针 指向被调用的成员函数所属的对象</span></span><br><span class="line">        <span class="comment">//age = age;无法区分</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Person&amp; <span class="title">PersonAddAge</span><span class="params">(<span class="type">const</span> Person&amp;p)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果不加引用返回的是p2的副本而不是本体</span></span><br><span class="line">        <span class="comment">//值的方式返回返回的是副本！！！</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="comment">//this是指向p2的指针 *this就是返回p2的本体</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//链式编程思想</span></span><br><span class="line">    p2.<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1);</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h4><ul>
<li>c++中允许空指针调用成员函数 但是也要注意有没有用到this函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;this is Person class&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性的前面默认加了this-&gt;age 报错的原因是传入的指针为空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">//这样提高代码的健壮性</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age = &quot;</span>&lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person* p = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  p-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line">  </span><br><span class="line">  p-&gt;<span class="built_in">showPersonAge</span>();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><ul>
<li>常函数 常函数内不可以修改成员属性 成员属性加mutable关键字之后在常函数依然可以修改</li>
<li>常对象 常对象只能调用常函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//this指针的本质是指针常量 指针的指向是不可以修改的</span></span><br><span class="line">  <span class="comment">//const Person* const this</span></span><br><span class="line">  <span class="comment">//在成员函数后面加const,修饰的是this指向，让指针指向的值也不可以修改</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//此处const对应的是最顶层的const 它的位置不定</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">   <span class="comment">//m_A = 100;</span></span><br><span class="line">   <span class="comment">//this = NULL；</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> m_A;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">int</span> m_B;<span class="comment">//特殊变量 即使在常函数中 也可以修改这个值 加上关键字mutable</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person p;</span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">const</span> Person p;<span class="comment">//在对象前加const 变为常对象</span></span><br><span class="line">  <span class="comment">//p.m_A = 100 不可以修改</span></span><br><span class="line">  p.m_B = <span class="number">100</span>;<span class="comment">//在常对象下可以修改</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//常对象只能调用常函数</span></span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">  <span class="comment">//p.func(); 不正确的 因为普通成员函数可能修改静态变量的值</span></span><br></pre></td></tr></table></figure>

<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ul>
<li>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问 就需要用到友元技术</li>
<li>友元的目的就是让一个函数或者类 访问另一个类中私有成员</li>
<li>友元的关键字为friend</li>
</ul>
<h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>&#123;</span><br><span class="line">    <span class="comment">//goodGay全局函数是 building类的好朋友可以访问私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>()&#123;</span><br><span class="line">        m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building&amp; building)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友全局函数正在访问：&quot;</span> &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友全局函数正在访问：&quot;</span> &lt;&lt; building.m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Building building;</span><br><span class="line">    <span class="built_in">goodGay</span>(building);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GoodGay</span>;<span class="comment">//GoodGay是本类的好朋友可以访问本类的私有成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">// 参观函数 访问Building中的属性</span></span><br><span class="line">    Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()&#123;</span><br><span class="line">    m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() &#123;</span><br><span class="line">    <span class="comment">//创建建筑物对象</span></span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友类正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友类正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GoodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//让visit函数访问Building中私有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;</span><br><span class="line">    Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">    m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() &#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果成员函数作为友元那么就必须将成员函数的实现写在类外</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visit函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visit函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visi2t函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;visit函数正在访问：&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GoodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">    gg.<span class="built_in">visit2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>####加号运算符重载</p>
<p>作用：实现两个自定义数据类型相加的运算</p>
<ul>
<li>通过成员函数重载</li>
<li>通过全局函数重载</li>
</ul>
<p>但是注意 内置的数据类型表达式的运算符是不可能改变的 不要滥用运算符重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">对于内置数据类型 编译器知道如何进行计算</span><br><span class="line"><span class="comment">//运算符重载 编译器给起了一个通用名称</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//通过成员函数重载号</span></span><br><span class="line">  Person <span class="keyword">operator</span>+ (Person&amp; p)&#123;</span><br><span class="line">  Person temp;</span><br><span class="line">  temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">  temp.m_B = <span class="keyword">this</span>-&gt;m_A + p.m_B;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person p3 = p1.operator+(p2) 可以简化成 Person p3 = p1 + p2;</span></span><br><span class="line">  <span class="built_in">Person</span>()&#123;&#125;;</span><br><span class="line">  <span class="type">int</span> m_A;</span><br><span class="line">  <span class="type">int</span> m_B;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过全局函数重载+  可以简化成 Person p3 = p1 + p2;</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1,Person&amp; p2)&#123;</span><br><span class="line">  Person temp;</span><br><span class="line">  temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">  temp.m_B = p1.m_B + p2.m_B;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">  <span class="comment">//注意不能返回局部变量的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person p3 = operator+ (p1,p2);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载可以发生函数重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp; p1, <span class="type">int</span> num)&#123;</span><br><span class="line">  Person temp;</span><br><span class="line">  temp.m_A = p1.m_A + num;</span><br><span class="line">  temp.m_B = p1.m_B + num;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;            </span><br><span class="line">  Person p1;</span><br><span class="line">  p1.m_A = <span class="number">10</span>;</span><br><span class="line">  p1.m_B = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  Person p2;</span><br><span class="line">  p2.m_A = <span class="number">10</span>;</span><br><span class="line">  p2.m_B = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><p>重载左移运算符配合友元实现任意类型的输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout,Person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        m_A = a;</span><br><span class="line">        m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//利用成员函数重载 左移运算符 p.operator&lt;&lt;(cout) 简化之后 p&lt;&lt;cout</span></span><br><span class="line">    <span class="comment">//不会利用成员函数重载&lt;&lt;运算符 因为无法实现cout在左侧</span></span><br><span class="line">    <span class="comment">//void operator&lt;&lt;(cout)</span></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能利用全局函数重载</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout,Person&amp; p)&#123;</span><br><span class="line">    <span class="comment">//注意ostream全局只能存在一个 不允许复制 所以必须返回引用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; m_B = &quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout,<span class="type">const</span> MyInteger&amp; myint);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>()&#123;</span><br><span class="line">        m_Num = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载前置++运算</span></span><br><span class="line">     MyInteger&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        <span class="comment">//一定要返回引用 为了返回的是本体</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//int 代表的是一个站位参数 可以用于区分前置和后置递增</span></span><br><span class="line">     MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">        <span class="comment">//编译器就默认加上占位参数后为后置递增运算</span></span><br><span class="line">        <span class="comment">//此处只能返回值</span></span><br><span class="line">        <span class="comment">//先记录当时结果</span></span><br><span class="line">        MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//后递增</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="comment">//返回记录结果</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout,<span class="type">const</span> MyInteger&amp; myint)&#123;</span><br><span class="line">    <span class="comment">//这里的第二个参数为什么要把引用去掉呢？？</span></span><br><span class="line">    <span class="comment">//为什么加了一个const又可以了呢？临时变量不能作为非const引用参数</span></span><br><span class="line">    cout &lt;&lt; myint.m_Num;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyInteger myint;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; myint++ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ul>
<li>默认构造函数 </li>
<li>默认析构函数</li>
<li>默认拷贝函数</li>
<li>赋值运算符 对属性进行值拷贝</li>
</ul>
<p>如果类中有属性指向堆区 做赋值操作时也会出现深浅拷贝问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">        m_age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_age != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> m_age;</span><br><span class="line">            m_age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(Person&amp; p)&#123;</span><br><span class="line">        <span class="comment">//一定要用引用或者指针的方式进行传递</span></span><br><span class="line">        <span class="comment">//返回值必须是本身才能做连等操作</span></span><br><span class="line">        <span class="comment">//编译器提供的是浅拷贝</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//应该先判断是否有属性在堆区 如果有应该先释放干净 再深拷贝</span></span><br><span class="line">        <span class="keyword">if</span>(m_age != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> m_age;</span><br><span class="line">            m_age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        m_age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_age);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>* m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *(p1.m_age) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *(p2.m_age) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *(p3.m_age) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="type">int</span> age)&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载==号</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载!=号</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数调用运算重载"><a href="#函数调用运算重载" class="headerlink" title="函数调用运算重载"></a>函数调用运算重载</h4><ul>
<li>函数调用运算符()也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用 因此也称为仿函数</li>
<li>仿函数没有固定写法 非常灵活</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数调用运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint02</span><span class="params">(string test)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world!&quot;</span>);<span class="comment">//由于使用起来非常像函数 所以称为仿函数</span></span><br><span class="line">    <span class="built_in">MyPrint02</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仿函数非常灵活 没有一个固定的写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyAdd myadd;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">myadd</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//匿名函数对象</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>,<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型转换运算符重载"><a href="#类型转换运算符重载" class="headerlink" title="类型转换运算符重载"></a>类型转换运算符重载</h4><ul>
<li>operator type( ) const;</li>
<li>tips：类型转换函数必须是类的成员函数 它不能声明返回类型 形参列表也必须为空。类型转换函数通常应该是const</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>) : <span class="built_in">val</span>(i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型转换运算符的定义中使用任何形参。同时，尽管类型转换函数不负责指定返回类型。但实际上每个类型转换函数都会返回一个对应类型的值。</span><br></pre></td></tr></table></figure>





<p>###继承</p>
<p>继承是面向对象三大特性之一</p>
<h4 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h4><ul>
<li>派生类中的成员 包含两大部分 一类从基类继承过来表现其共性 而新增的成员体现了其个性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;首页 公开课 (公开头部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;帮助中心 交流合作 (公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;首页 公开课 (公开头部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;帮助中心 交流合作 (公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Java ja;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;JAVA下载视频页面如下&quot;</span> &lt;&lt; endl;</span><br><span class="line">  ja.<span class="built_in">header</span>();</span><br><span class="line">  ja.<span class="built_in">footer</span>();</span><br><span class="line">  ja.<span class="built_in">content</span>();</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Python py;</span><br><span class="line">  py.<span class="built_in">header</span>();</span><br><span class="line">  py.<span class="built_in">footer</span>();</span><br><span class="line">  py.<span class="built_in">content</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//继承实现页面</span></span><br><span class="line"><span class="comment">//基本语法 class 子类 ：继承方式 父类</span></span><br><span class="line"><span class="comment">//子类 也称为派生类 父类 也称为 基类</span></span><br><span class="line"><span class="comment">//优点：减少重复代码</span></span><br><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;首页 公开课 (公开头部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;帮助中心 交流合作 (公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span>:<span class="keyword">public</span> BasePage&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>:<span class="keyword">public</span> BasePage&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h4><ul>
<li>一共三种继承方式 公共继承 保护继承 私有继承</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">不可访问：</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">protected</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">不可访问：</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">private</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">不可访问：</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><ul>
<li>从基类继承过来的成员，哪些属于派生类对象中？</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 结果是 16 ABCD都是它的对象 都会继承并且保留</span></span><br><span class="line">  <span class="comment">//在基类中所有非静态成员属性都会被子类继承下去</span></span><br><span class="line">  <span class="comment">//基类中私有成员属性是被编译器隐藏了 因此访问不到 但是确实是继承下去了</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Size of Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h4><ul>
<li>子类和父类的构造和析构函数是谁先谁后？</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ～<span class="built_in">Base</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="built_in">Son</span>()&#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Son的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ～<span class="built_in">Son</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Son s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承中同名成员处理方式"><a href="#继承中同名成员处理方式" class="headerlink" title="继承中同名成员处理方式"></a>继承中同名成员处理方式</h4><ul>
<li>当子类和父类出现同名的成员 如何通过子类对象 访问子类或父类中同名数据呢？</li>
<li>访问子类同名成员 直接访问    访问父类同名成员 需要加作用域</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>()&#123;</span><br><span class="line">    m_A = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base下的func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base下的func(int a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son</span>()&#123;</span><br><span class="line">    m_A = <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son下的func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Son s;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Son m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//如果通过子类对象访问父类中同名成员 需要加上作用域</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Base m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Son s;</span><br><span class="line">  </span><br><span class="line">  s.<span class="built_in">func</span>();<span class="comment">//直接调用调用的是子类中的同名成员</span></span><br><span class="line">  </span><br><span class="line">  s.Base::<span class="built_in">func</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏父类中所有同名成员函数</span></span><br><span class="line">  <span class="comment">//如果想访问到父类中被隐藏的同名成员函数 需要加作用域</span></span><br><span class="line">  s.Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏父类中所有同名成员函数，如果想访问到父类中被隐藏的同名成员函数需要加作用域</li>
</ul>
<h4 id="同名静态成员处理"><a href="#同名静态成员处理" class="headerlink" title="同名静态成员处理"></a>同名静态成员处理</h4><ul>
<li>继承中同名的静态成员在子类对象如何进行访问？</li>
<li>访问子类同名成员 直接访问即可  访问父类同名成员 需要加作用域</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base的Static func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son的Static func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>; <span class="comment">//类外初始化</span></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Son s;</span><br><span class="line">  <span class="comment">//通过对象访问</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Son m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Base m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过类名访问</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Son m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Base m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Son s;</span><br><span class="line">  s.<span class="built_in">func</span>();</span><br><span class="line">  s.Base::<span class="built_in">func</span>();</span><br><span class="line">  </span><br><span class="line">  Son::<span class="built_in">func</span>();</span><br><span class="line">  Son::Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结</p>
<ul>
<li>同名静态成员处理方式和非静态处理方式一样 只不过有两种访问方式（对象和类名）</li>
</ul>
<h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><ul>
<li>语法 class 子类 ：继承方式 父类 ，继承方式 父类2</li>
<li>多继承可能引发父类中有同名成员出现 需要加作用域区分</li>
<li>C++实际开发中不建议使用多继承</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>()&#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>()&#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类 需要继承Base1和Base2</span></span><br><span class="line"><span class="comment">//语法 class 子类 ： 继承方式 父类1 ， 继承方式 父类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()&#123;</span><br><span class="line">        m_C = <span class="number">300</span>;</span><br><span class="line">        m_D = <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当父类中出现同名成员，需要加作用域区分</span></span><br><span class="line">    cout &lt;&lt;  <span class="string">&quot;Son Base1 m_A = &quot;</span> &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt;  <span class="string">&quot;Son Base2 m_A = &quot;</span> &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><ul>
<li><p>菱形继承的概念：</p>
<p>两个派生类继承同一个基类 又有某个类同时继承两个派生类 这种继承被称为菱形继承或者钻石继承</p>
</li>
<li><p>菱形继承问题：</p>
<ol>
<li>羊继承了动物的数据 驼同样继承了动物的数据 当草泥马(羊驼)使用数据行 就会产生二义性</li>
<li>草泥马继承自动物的数据继承了两份 但是其实只需要一份就可以了</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用虚继承 解决菱形继承的问题</span></span><br><span class="line"><span class="comment">//继承之前 加上关键字 virtual 变成虚继承</span></span><br><span class="line"><span class="comment">//Animal称为 虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当菱形继承时，两个父类拥有相同数据 需要加作用域区分</span></span><br><span class="line">    st.Sheep::m_Age = <span class="number">18</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这份数据我们知道其实只有一份就可以了 菱形继承导致数据有两份资源浪费</span></span><br><span class="line">    <span class="comment">//答案是 28</span></span><br><span class="line">    cout &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vbptr virtual base pointer</span></span><br><span class="line"><span class="comment"> * 指向vbtable虚基类表 地址偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h4><p>多态分为两类</p>
<ul>
<li>静态多态：函数重载和运算符重载属于静态多态 复用函数名</li>
<li>动态多态：派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态的区别：</p>
<ul>
<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>
</ul>
<p>动态多态的满足条件：</p>
<ul>
<li>有继承关系 </li>
<li>子类重写父类的虚函数 </li>
</ul>
<p>动态多态的使用：父类的指针或者引用 指向子类对象 程序将使用为对象类型定义的成员函数 而不使用为引用或指针类型定义的成员函数 这称为动态连便或晚期联编</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//虚函数 父类必须写 子类可写可不写</span></span><br><span class="line">    <span class="comment">//重写 函数返回值类型 函数名 参数列表 完全相同</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果不加virtual 地址早绑定 在编译阶段确定函数地址</span></span><br><span class="line"><span class="comment">//如果想执行让猫说话 那么这个函数地址就不能提前绑定 需要在运行阶段进行绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSpeak</span><span class="params">(Animal&amp; animal)</span></span>&#123; <span class="comment">// Animal&amp; animal = cat</span></span><br><span class="line">    <span class="comment">//C++中允许父子类型的转换</span></span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">doSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line">    Dog dog;</span><br><span class="line">    <span class="built_in">doSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//答案是8 是一个指针</span></span><br><span class="line">  <span class="comment">//vfptr virtual function pointer 虚函数指针</span></span><br><span class="line">  <span class="comment">//vftable 虚函数表 表的内部记录虚函数的地址</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;size of animal = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Animal) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何理解多态的本质</strong></p>
<p>![image-20220712113521341](/Users/valerian/Library/Application Support/typora-user-images/image-20220712113521341.png)</p>
<h4 id="多态案例一-计算器类"><a href="#多态案例一-计算器类" class="headerlink" title="多态案例一 计算器类"></a>多态案例一 计算器类</h4><p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展和维护</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper == <span class="string">&quot;+&quot;</span>) <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(oper == <span class="string">&quot;-&quot;</span>) <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(oper == <span class="string">&quot;*&quot;</span>) <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">        <span class="comment">//如果有不同的操作 那么还需要修改源码 在真实的开发中 提倡开闭原则 对扩展进行开发 对修改进行关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Num1;</span><br><span class="line">    <span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用多态实现计算器</span></span><br><span class="line"><span class="comment">//实现计算器的抽象类 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Num1;</span><br><span class="line">    <span class="type">int</span> m_Num2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> : <span class="keyword">public</span> AbstractCalculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> : <span class="keyword">public</span> AbstractCalculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> : <span class="keyword">public</span> AbstractCalculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//没有使用多态的</span></span><br><span class="line">    Calculator c;</span><br><span class="line">    c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">    c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//多态使用条件 父类指针或者引用指向子类对象</span></span><br><span class="line">    <span class="comment">//实现加法</span></span><br><span class="line">    AbstractCalculator* cal = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">    cal-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">    cal-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cal-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> cal;</span><br><span class="line">    cal = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><ul>
<li>在多态中 通常父类中虚函数的实现是毫无意义的 主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数</li>
<li>纯虚函数语法 ：virtual 返回值 函数类型 函数名 (参数列表)  = 0；</li>
<li>当类中有了纯虚函数 这个类也称为抽象类</li>
</ul>
<p>抽象类的特点</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数 否则也属于抽象类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//只要有一个纯虚函数 这个类称为抽象类 </span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Son s;<span class="comment">//子类必须重写父类中的纯虚函数 否则也属于抽象类</span></span><br><span class="line">  Base* base = <span class="keyword">new</span> Son;</span><br><span class="line">  base-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多态案例二-制作饮品"><a href="#多态案例二-制作饮品" class="headerlink" title="多态案例二-制作饮品"></a>多态案例二-制作饮品</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddIngredient</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">Boil</span>();</span><br><span class="line">        <span class="built_in">Brew</span>();</span><br><span class="line">        <span class="built_in">PourInCup</span>();</span><br><span class="line">        <span class="built_in">AddIngredient</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;煮农夫山泉&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;冲泡咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddIngredient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入糖和牛奶&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;煮矿泉水&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;冲泡茶叶&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;倒入茶杯&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddIngredient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入柠檬&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(AbstractDrinking* abstractDrinking)</span></span>&#123;</span><br><span class="line">    abstractDrinking-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">    <span class="keyword">delete</span> abstractDrinking;</span><br><span class="line">    abstractDrinking = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">doWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">doWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>多态使用时 如果子类中有属性开辟到堆区 那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方法：将父类中的析构函数改为虚析构或者纯虚析构</p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯析构的区别：</p>
<ul>
<li>如果是 纯析构 该类属于抽象类 无法实例化对象</li>
</ul>
<p>虚析构函数语法： virtual ~类名(){}</p>
<p>纯虚析构函数语法：virtual ~类名() = 0;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用虚析构可以解决 父类指针释放子类对象时不干净的问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//纯虚析构 需要声明也需要实现</span></span><br><span class="line">    <span class="comment">//有了纯虚析构函数之后 这个类也属于抽象类 无法实例化对象</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>; <span class="comment">//会报错 虚析构和纯虚析构都需要代码实现 因为父类也有可能有代码开辟到堆区 virtual 关键字只能定义在类内 在类内声明在类外实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal:: ~<span class="built_in">Animal</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Animal纯虚析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cat</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_Name!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Cat的析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> m_Name;</span><br><span class="line">            m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; *m_Name &lt;&lt;<span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string* m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Animal* animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="comment">//父类指针在析构时候 不会调用子类析构函数 导致子类如果有堆区属性 出现内存泄漏的情况</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">    animal = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</li>
<li>如果子类中没有堆区数据 可以不写虚析构或纯虚析构</li>
<li>拥有纯虚析构函数的类也属于抽象类</li>
</ul>
<h4 id="多态案例三-电脑组装"><a href="#多态案例三-电脑组装" class="headerlink" title="多态案例三 - 电脑组装"></a>多态案例三 - 电脑组装</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象计算函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">Calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GPU</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Computer</span>(CPU* cpu,GPU* gpu,Memory* memory)&#123;</span><br><span class="line">        m_cpu = cpu;</span><br><span class="line">        m_gpu = gpu;</span><br><span class="line">        m_mem = memory;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Computer</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_mem != <span class="literal">NULL</span>) <span class="keyword">delete</span> m_mem;</span><br><span class="line">        <span class="keyword">if</span>(m_cpu != <span class="literal">NULL</span>) <span class="keyword">delete</span> m_cpu;</span><br><span class="line">        <span class="keyword">if</span>(m_gpu != <span class="literal">NULL</span>) <span class="keyword">delete</span> m_gpu;</span><br><span class="line">        m_mem = <span class="literal">NULL</span>;</span><br><span class="line">        m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">        m_gpu = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m_cpu-&gt;<span class="built_in">Calculate</span>();</span><br><span class="line">        m_gpu-&gt;<span class="built_in">Display</span>();</span><br><span class="line">        m_mem-&gt;<span class="built_in">Storage</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CPU* m_cpu;</span><br><span class="line">    GPU* m_gpu;</span><br><span class="line">    Memory* m_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> : <span class="keyword">public</span> CPU&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel cpu is running&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelGPU</span> : <span class="keyword">public</span> GPU&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel cpu is displaying&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> : <span class="keyword">public</span> Memory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Storage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel memory is storing&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> : <span class="keyword">public</span> CPU&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo cpu is running&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoGPU</span> : <span class="keyword">public</span> GPU&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; Lenovo cpu is displaying&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> : <span class="keyword">public</span> Memory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Storage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo memory is storing&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CPU* intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">    GPU* intelGpu = <span class="keyword">new</span> IntelGPU;</span><br><span class="line">    Memory* intelmemory = <span class="keyword">new</span> IntelMemory;</span><br><span class="line">    Computer* computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu,intelGpu,intelmemory);</span><br><span class="line">    computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer1;</span><br></pre></td></tr></table></figure>

<p>##文件操作</p>
<p>程序运行时的数据都属于临时数据 程序一旦运行结束都会被释放掉</p>
<p>c++对文件操作都需要包含<fstream></p>
<p>文件类型分为两类：</p>
<ol>
<li>文本文件 文本以ASCII码形式存储在计算机中</li>
<li>二进制文件</li>
</ol>
<p>操作文件的三大类</p>
<ol>
<li>ofstream 写操作</li>
<li>ifstream 读操作</li>
<li>fstream 读写操作</li>
</ol>
<h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>写文件的步骤：1.包含头文件 2.创建流对象 3.打开文件 4.写数据 5.关闭文件</p>
<p>文件打开的方式</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置 文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p>注意：文件打开方式可以配合使用 利用｜操作符号</p>
<p>总结：</p>
<p>利用 &lt;&lt; 可以写文件</p>
<p>记得关闭文件！</p>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>读取的步骤：</p>
<p>1.包含头文件 2.创建流对象 3.打开文件并判断额恩间是否打开成功 4.读数据  四种方式读取 5.关闭文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fstream ifs;</span><br><span class="line">  ifs.<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,ios::in);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span>(ifs &gt;&gt; buf)&#123;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span>(ifs.<span class="built_in">getline</span>(buf,<span class="number">1024</span>)) &#123;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="keyword">while</span>((c = ifs.<span class="built_in">get</span>()) != EOF)&#123;</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; endl;</span><br><span class="line">  ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>标准C++提供了一个显示的转换的语法，来代替旧的C风格的类型转换。</p>
<p>使用C风格的强制转换可以把想要的任何东西转换成我们需要的类型。那为什么还需要一个新的C++类型的强制转换呢？</p>
<p>新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么，程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。</p>
<h3 id="静态转换-static-cast"><a href="#静态转换-static-cast" class="headerlink" title="静态转换(static_cast)"></a>静态转换(static_cast)</h3><ul>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。<ul>
<li>进行上行转换是安全的。</li>
<li>进行下行转换时，由于没有动态类型检查，所以是不安全的。</li>
</ul>
</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把char转换成int。这种转换的安全性也要开发人员来保证。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//允许内置数据类型之间转换</span></span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a);</span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base* base = <span class="literal">NULL</span>;</span><br><span class="line">    Son* son = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//语法 static_cast&lt;目标类型&gt;(原对象/原变量)</span></span><br><span class="line">    <span class="comment">//父子之间的指针或者引用的转化</span></span><br><span class="line">    <span class="comment">//将base转为Son*父转子 向下类型转换 不安全</span></span><br><span class="line">    Son* son2 = <span class="built_in">static_cast</span>&lt;Son *&gt;(base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将son转换为Base* 子转父 向上类型转换 安全</span></span><br><span class="line">    Base* base2 = <span class="built_in">static_cast</span>&lt;Base*&gt;(son);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base转换成other* 转换失败</span></span><br><span class="line">    <span class="comment">//Other* other = static_cast&lt;Other&gt;(base);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态转换-dynamic-cast"><a href="#动态转换-dynamic-cast" class="headerlink" title="动态转换(dynamic_cast)"></a>动态转换(dynamic_cast)</h3><ul>
<li>dynamic_cast主要用于类层次间的上行转换和下行转换。</li>
<li>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。</li>
<li>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//不允许内置数据类型之间转换 错误的</span></span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="comment">//double d = dynamic_cast&lt;double&gt;(c);</span></span><br><span class="line"></span><br><span class="line">    Base* base = <span class="literal">NULL</span>;</span><br><span class="line">    Son* son = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Base转换成son 父转子 不安全 如果发生了多态，那么转换总是安全的，否则报错</span></span><br><span class="line">    Son* son2 = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将son转换成为Base* 子转父 安全</span></span><br><span class="line">    Base* base2 = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(son);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base转Other* 不安全 错误</span></span><br><span class="line">    <span class="comment">//Other* other = dynamic_cast&lt;Other*&gt;(base);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量转换-const-cast"><a href="#常量转换-const-cast" class="headerlink" title="常量转换(const_cast)"></a>常量转换(const_cast)</h3><p>该运算符用来修改类型的const属性</p>
<ul>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量引用，并且仍指向原来的对象</li>
</ul>
<p>注意：不能直接对非指针和非引用的变量使用const_cast操作符去直接移除const</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//不可以将非指针或非引用做const_cast转换</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span>* np = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p);</span><br><span class="line">    <span class="type">int</span>* pp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* npp = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(pp);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//int b = const_cast&lt;int&gt;(a);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常量引用转换成非常量引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; refNum = num;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; refNum2 = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>&amp;&gt;(refNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重新解释转换"><a href="#重新解释转换" class="headerlink" title="重新解释转换"></a>重新解释转换</h3><p>这是最不安全的一种转换机制 最有可能出现问题。</p>
<p>主要用于将一种数据类型从一种类型转换成为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(a);</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    Base* base = <span class="literal">NULL</span>;</span><br><span class="line">    Other* other = <span class="built_in">reinterpret_cast</span>&lt;Other*&gt;(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-异常"><a href="#C-异常" class="headerlink" title="C++异常"></a>C++异常</h2><h3 id="异常基本概念"><a href="#异常基本概念" class="headerlink" title="异常基本概念"></a>异常基本概念</h3><p>异常处理就是处理程序中的错误，所谓错误是指在你程序运行的过程中发生的一些异常事件（如：除0溢出，数组下标越界，所要读取的文件不存在，空指针，内存不足等等）</p>
<h3 id="C-异常基本语法"><a href="#C-异常基本语法" class="headerlink" title="C++异常基本语法"></a>C++异常基本语法</h3><ul>
<li>C异常机制</li>
</ul>
<p>在C语言中对错误的处理围绕两种方法：一是使用整型的返回值标识错误，二是使用emo宏（可以简单的理解为一个全局整型变量）去记录错误。这两种方法最大的缺陷就是会出现不一致问题，其次还有一个缺点是函数的返回值只有一个。</p>
<ul>
<li>C++异常机制</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printError</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我自己的异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myDivision</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//throw -1; //返回一个int类型的异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>(); <span class="comment">//抛出MyException</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">myDivision</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">int</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;int类型异常捕获&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(MyException e)&#123;</span><br><span class="line">        e.<span class="built_in">printError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        <span class="comment">//捕获到了异常，但是不想在此处处理，继续向上抛出这个异常</span></span><br><span class="line">        <span class="comment">//异常必须有函数进行处理，如果没有任何处理，程序自动调用terminate函数，终端程序</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">double</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;main函数里面的double类型异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;main函数里面的其他类型异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>若有异常则通过thorw操作创建一个异常对象并抛出</li>
<li>将可能抛出异常的程序段放到try块之中。</li>
<li>如果在try段执行期间没有引起异常，那么跟在try后面的catch字句就不会执行</li>
<li>catch子句会根据出现的先后顺序被检查，匹配的catch语句捕获并处理异常（或继续抛出异常）</li>
<li>如果匹配的处理未找到，则运行函数terminate将被自动调用，其缺省功能调用abort终止程序</li>
<li>处理不了的异常可以在catch的最后一个分支，使用throw，向上抛</li>
</ol>
<h3 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从try代码块开始，到throw抛出异常之前，所有栈上的数据都会被释放掉，</span></span><br><span class="line"><span class="comment">//释放的顺序和创建顺序相反，这个过程叫做栈解旋</span></span><br></pre></td></tr></table></figure>

<h3 id="异常的严格类型匹配"><a href="#异常的严格类型匹配" class="headerlink" title="异常的严格类型匹配"></a>异常的严格类型匹配</h3><p>异常机制和函数机制互不干涉，但是捕捉方式是通过严格类型匹配</p>
<h3 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h3><ul>
<li>为了加强程序的可读性，可以在函数声明中列出可能抛出异常的所有类型，例如：void func( ) throw(A,B,C) 这个函数能够且只能抛出类型A，B，C及其子类型的异常</li>
<li>如果在函数声明中没有包含异常借口声明，则此函数可以抛任何类型的异常</li>
<li>一个不能抛任何类型异常的函数可声明未void func( ) throw( )</li>
<li>如果一个函数抛出它的异常接口声明所不允许抛出的异常，unexpected函数会被调用，该函数默认行为调用terminate函数中断程序 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>,<span class="type">double</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常变量的声明周期"><a href="#异常变量的声明周期" class="headerlink" title="异常变量的声明周期"></a>异常变量的声明周期</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyException默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyException</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyException析构构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="type">const</span> MyException&amp; e)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyException拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">MyException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抛出的是throw MyException()； catch(MyException e）会调用拷贝构造函数效率低</span></span><br><span class="line">    <span class="comment">//抛出的是throw MyException()； catch(MyException&amp; e）不会调用拷贝构造函数效率高</span></span><br><span class="line">    <span class="built_in">catch</span>(MyException&amp; e)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyException异常捕获&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常的多态使用"><a href="#异常的多态使用" class="headerlink" title="异常的多态使用"></a>异常的多态使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异常的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseException</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printError</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//空指针异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NULLPointerException</span>:<span class="keyword">public</span> BaseException&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printError</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;空指针异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//越界异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutOfRangeExceprion</span>:<span class="keyword">public</span> BaseException&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printError</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;越界异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">NULLPointerException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//利用父类引用指向子类对象</span></span><br><span class="line">    <span class="built_in">catch</span>(BaseException&amp; e)&#123;</span><br><span class="line">        e.<span class="built_in">printError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标准异常库"><a href="#标准异常库" class="headerlink" title="标准异常库"></a>标准异常库</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;年龄越界&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">Person</span>(<span class="number">151</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用多态</span></span><br><span class="line">    <span class="built_in">catch</span>(exception&amp; e)&#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写自己的异常类"><a href="#编写自己的异常类" class="headerlink" title="编写自己的异常类"></a>编写自己的异常类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyOutOfRangeException</span>:<span class="keyword">public</span> exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyOutOfRangeException</span>(<span class="type">const</span> <span class="type">char</span>* str)&#123;</span><br><span class="line">        <span class="comment">//const chat* 隐式类型转换为 string 反之不可以</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_errorInfo = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyOutOfRangeException</span>(string str)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_errorInfo = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT</span>&#123;</span><br><span class="line">        <span class="comment">//将string转为const char *</span></span><br><span class="line">        <span class="keyword">return</span> m_errorInfo.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    string m_errorInfo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">MyOutOfRangeException</span>(<span class="built_in">string</span>(<span class="string">&quot;exception:年龄越界&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">Person</span>(<span class="number">151</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用多态</span></span><br><span class="line">    <span class="built_in">catch</span>(exception&amp; e)&#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##C++标准库特殊设施</p>
<p>###tuple</p>
<p>###bitset</p>
<p>###正则表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line">regex 表示有一个正则表达式的类</span><br><span class="line">regex_match 将一个字符序列与一个正则表达式匹配</span><br><span class="line">regex_search 寻找第一个与正则表达式匹配的子序列</span><br><span class="line">regex_replace 使用给定格式替换一个正则表达式</span><br><span class="line">sregex_iterator 迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串</span><br><span class="line">smatch 容器类 保存在string中搜索的结果</span><br><span class="line">ssub_match string中匹配的子表达式的结果</span><br></pre></td></tr></table></figure>

<p>####使用正则表达式库</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">pattern</span><span class="params">(<span class="string">&quot;[^c]ei&quot;</span>)</span></span>; <span class="comment">//查找不在字符c之后的字符串ei</span></span><br><span class="line"></span><br><span class="line">pattern = <span class="string">&quot;[[:alpha:]]*&quot;</span> + pattern + <span class="string">&quot;[[:alpha:]]*&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(pattern)</span></span>; <span class="comment">//构造一个用于查找模式的regex</span></span><br><span class="line"></span><br><span class="line">smatch results; <span class="comment">//定义一个对象保存搜索结果</span></span><br><span class="line"></span><br><span class="line">string test_str = <span class="string">&quot;receipt freind theif receive&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">regx_search</span>(test_str,results,r)) <span class="comment">//用r在test_str中查找与pattern匹配的子串 只要找到一个匹配子串就会停止</span></span><br><span class="line"> </span><br><span class="line">  cout &lt;&lt; results.<span class="built_in">str</span>() &lt;&lt; endl; <span class="comment">//打印匹配的单词</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tips:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[[::alpha:]] <span class="comment">//用来匹配任意字母</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Another example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  smatch results;</span><br><span class="line">  string str = <span class="string">&quot;HyperWorks contains HyperView and HyperStudy&quot;</span>;</span><br><span class="line">  <span class="function">string <span class="title">pat</span><span class="params">(<span class="string">&quot;Hyper[^ ]+[ |.]&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function">string <span class="title">pat1</span><span class="params">(<span class="string">&quot;Hyper.*\\.&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function">regex <span class="title">r</span><span class="params">(pat1)</span></span>;</span><br><span class="line"><span class="comment">//  for(sregex_iterator it(str.begin(),str.end(),r),end_it;it != end_it; ++it)&#123;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; it-&gt;str() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  string str2;</span></span><br><span class="line"><span class="comment">//  str2 = regex_replace(str,r,&quot;hello &quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  cout &lt;&lt; str2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">regex_match</span>(str,results,r))&#123;</span><br><span class="line">      cout &lt;&lt; results[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;not match&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>For语句中的初始值定义了it和end_it。当我们定义it时，sregex_iterator 的构造函数调用regex_search将it定位到file中第一个与r匹配的位置。而end_it是一个空sregex_iterator，起到尾后迭代器的作用。for语句中的递增运算通过regex_search来推进迭代器。当我们解引用迭代器时，会得到一个表示当前匹配结果的smatch对象。我们调用它的str成员函数来打印匹配的成员。</li>
<li></li>
</ul>
<h4 id="指定regex对象的选项"><a href="#指定regex对象的选项" class="headerlink" title="指定regex对象的选项"></a>指定regex对象的选项</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(re)</span></span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(re,f)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">re表示一个正则表达式，它可以是一个string、一个表示字符范围的迭代器对、一个指向空字符结尾的字符数组的指针、一个字符指针和一个计数器或是一个花括号包围的字符列表。f是指出对象如何处理的标志、f通过下面列出的值来设置。如果未指定f，其默认值为ECMAScript</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">r1 </span>= re</span><br><span class="line">将r1中的正则表达式替换成re。re表示一个正则表达式，它可以是另一个regex对象、一个string、一个指向空字符结尾的字符数组的指针或是一个花括号包围的字符列表</span><br><span class="line"> </span><br><span class="line"> r1.<span class="built_in">assign</span>(re,f)</span><br></pre></td></tr></table></figure>



<p>##C++反射</p>
<h3 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h3><ul>
<li>指程序在运行时，访问、检测和修改它本身状态或行为的一种能力</li>
<li>简单的来说，就是一种自描述和自控制的能力。</li>
</ul>
<p>####反射的作用</p>
<p>反射机制可以用来：</p>
<ul>
<li>获取类型的信息，包含属性、方法</li>
<li>动态调用方法</li>
<li>动态构造对象</li>
<li>从程序集中获得类型</li>
</ul>
<p>####反射的缺点</p>
<ul>
<li>性能：反射可以理解成一种解释操作，这个过程总是要慢于直接调用的</li>
<li>反射模糊了程序内部实际发生的事情，会比直接代码更加复杂</li>
</ul>
<p>缺点不能掩饰其优点，针对不同的场景使用合理的技术。</p>
<p>####反射的使用场景</p>
<ul>
<li>序列化和数据绑定 Serializtion Data Binding</li>
<li>远程方法调用 RMI</li>
<li>对象/关系数据映射 (O/R mapping)</li>
</ul>
<p>####关于c++的反射</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul>
<li>C++序列化，与反序列化。序列化就是将对象编程二进制的形式存储在磁盘上，或者通过网络传输给另一台机器。反序列化就是序列化的逆过程。但是这个逆过程，必须要根据字符串来判断将二进制流转化成什么类型的对象。</li>
<li>工厂模式，常常是根据一个字符串来获取想要的对象。但是为了满足开闭原则，我们不能简单的在工厂类中不断的修改生产函数来扩展不同的类型。这个时候，需要利用反射，使用抽象类。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>使用map，映射字符串和生产函数</li>
<li>每次构造新类型时，将生产函数注册到map中</li>
<li>工厂函数通过map获得生产函数，建造不同的对象</li>
</ul>
<h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><ul>
<li>map存储在Object抽象父类中</li>
<li>使用ClassInfo辅助类型保存子类对象（包括了子类对象的构造函数）</li>
<li>map映射结构—-&gt;子类名称：ClassInfo*</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/2019043016404420.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyNjYwNzc1,size_16,color_FFFFFF,t_70" alt="这是一个图片"></p>
<p>第一步：定义一个函数指针类型 用于指向创建类实例的回调函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* (*PRTCreateObject)(<span class="type">void</span>);</span><br></pre></td></tr></table></figure>

<p>第二步：定义和实现一个工厂类，用于保存类名和创建类实例的回调函数。工厂类的作用仅仅是用来保存类名与创建类实例的回调函数，所以程序的整个证明周期内无需多个工厂类的实例，所以这里采用单例模式来涉及工厂类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassFactory.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* (*PTRCreateObject)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::map&lt;std::string, PTRCreateObject&gt; m_classMap;</span><br><span class="line">	<span class="built_in">ClassFactory</span>() &#123;&#125;; <span class="comment">//构造函数私有化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="title">getClassByName</span><span class="params">(std::string className)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">registClass</span><span class="params">(std::string name, PTRCreateObject method)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> ClassFactory&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类的实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@brief:获取工厂类的单个实例对象  </span></span><br><span class="line"><span class="function">ClassFactory&amp; <span class="title">ClassFactory::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> ClassFactory sLo_factory;</span><br><span class="line">	<span class="keyword">return</span> sLo_factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@brief:通过类名称字符串获取类的实例</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ClassFactory::getClassByName</span><span class="params">(std::string className)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> iter = m_classMap.<span class="built_in">find</span>(className);</span><br><span class="line">	<span class="keyword">if</span> (iter == m_classMap.<span class="built_in">end</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> iter-&gt;<span class="built_in">second</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@brief:将给定的类名称字符串和对应的创建类对象的函数保存到map中   </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassFactory::registClass</span><span class="params">(std::string name, PTRCreateObject method)</span> </span>&#123;</span><br><span class="line">	m_classMap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(name, method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步： 这一步比较重要，也是最值得深究的一步，也是容易犯迷糊的地方，仔细看。将定义的类注册到工厂类中。也就是说将类名称字符串和创建类实例的回调函数保存到工厂类的map中。这里我们又需要完成两个工作，第一个是定义一个创建类实例的回调函数，第二个就是将类名称字符串和我们定义的回调函数保存到工厂类的map中。假设我们定义了一个TestClassA。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test class A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClassA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">m_print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;hello TestClassA&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//@brief:创建类实例的回调函数</span></span><br><span class="line"><span class="function">TestClassA* <span class="title">createObjTestClassA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestClassA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，我们完了第一个工作，定义了一个创建类实例的回调函数。下面我们要思考一下如何将这个回调函数和对应的类名称字符串保存到工厂类的map中。我这里的一个做法是创建一个全局变量，在创建这个全局变量时，调用的构造函数内将回调函数和对应的类名称字符串保存到工厂类的map中。在这里，这个全局变量的类型我们定义为RegisterAction。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassFactory.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册动作类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RegisterAction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RegisterAction</span>(std::string className,PTRCreateObject ptrCreateFn)&#123;</span><br><span class="line">     ClassFactory::<span class="built_in">getInstance</span>().<span class="built_in">registClass</span>(className,ptrCreateFn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有个这个注册动作类，我们在每个类定义完成之后，我们就创建一个全局的注册动作类的对象，通过注册动作类的构造函数将我们定义的类的名称和回调函数注册到工厂类的map中。可以在程序的任何一个源文件中创建注册动作类的对象，但是在这里，我们放在回调函数后面创建。后面你就知道为什么这么做了。创建一个注册动作类的对象如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">RegisterAction <span class="title">g_creatorRegisterTestClassA</span><span class="params">(<span class="string">&quot;TestClassA&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">					(PTRCreateObject)createObjTestClassA)</span></span>;   </span><br></pre></td></tr></table></figure>

<p>到这里，我们就完成将类名称和创建类实例的回调函数注册到工厂类的map。下面再以另外一个类TestClassB为例，重温一下上面的步骤：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test class B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClassB</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">m_print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;hello TestClassB&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//@brief:创建类实例的回调函数</span></span><br><span class="line">TestClassB* createObjTestClassB&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestClassB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册动作类的全局实例</span></span><br><span class="line"><span class="function">RegisterAction <span class="title">g_creatorRegisterTestClassB</span><span class="params">(<span class="string">&quot;TestClassB&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">					(PTRCreateObject)createObjTestClassB)</span></span>;</span><br></pre></td></tr></table></figure>

<p>到这里，我们就完成将类名称和创建类实例的回调函数注册到工厂类的 map。下面再以另外一个类 TestClassB 为例，重温一下上面的步骤</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test class B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClassB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m_print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello TestClassB&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// brief: 创建类实例的回调函数</span></span><br><span class="line"><span class="function">TestClassB* <span class="title">createObjTestClassB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> TestClassB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册动作类的全局实例</span></span><br><span class="line"><span class="function">RegisterAction <span class="title">g_creatorRegisterTestClassB</span><span class="params">(<span class="string">&quot;TestClassB&quot;</span>,(PTRCreateObject)createObjTestClassB)</span></span>;</span><br></pre></td></tr></table></figure>

<p>聪明的你有没有发现，如果我们再定义一个类 C、D…，我们重复的在写大量相似度极高的代码。那么如何偷懒让代码变得简洁，提高编码效率呢。</p>
<p>有时我们就应该偷懒，不是说这个世界是懒人们创造的么，当然这些懒人们都很聪明。那么我们如何偷懒呢，如果你想到了宏，恭喜，答对了。其实仔细一看，包括回调函数的定义和注册动作类变量的定义，每个类的代码除了类名外其它都是一模一样的，那么我们就可以用下面的宏来替代这些重复代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER(className) 											\</span></span><br><span class="line"><span class="meta">	className* objectCreator##className()&#123;     							\</span></span><br><span class="line"><span class="meta">        return new className;                                         	\</span></span><br><span class="line"><span class="meta">    &#125;                                                                  	\</span></span><br><span class="line"><span class="meta">    RegisterAction g_creatorRegister##className(                        \</span></span><br><span class="line"><span class="meta">		#className,(PTRCreateObject)objectCreator##className)</span></span><br></pre></td></tr></table></figure>

<p>有了上面的宏，我们就可以在每个类后面简单的写一个 <code>REGISTER(ClassName)</code> 就完成了注册的功能</p>
<p>测试</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">m_print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;hello TestClass&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REGISTER</span>(TestClass);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	TestClass* ptrObj = (TestClass*)ClassFactory::<span class="built_in">getInstance</span>().<span class="built_in">getClassByName</span>(<span class="string">&quot;TestClass&quot;</span>);</span><br><span class="line">	ptrObj-&gt;<span class="built_in">m_print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="C-泛型编程"><a href="#C-泛型编程" class="headerlink" title="C++泛型编程"></a>C++泛型编程</h1><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><h3 id="模版的概念"><a href="#模版的概念" class="headerlink" title="模版的概念"></a>模版的概念</h3><p>模版就是建立通用的模具 大大提高复用性</p>
<p>模版的特点：模版不可以直接使用 只是一个框架 模版的通用并不是万能的</p>
<h3 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h3><ul>
<li>泛型编程主要就是利用模版</li>
<li>c++提供两种模版 函数模版和类模版</li>
</ul>
<h4 id="函数模版语法"><a href="#函数模版语法" class="headerlink" title="函数模版语法"></a>函数模版语法</h4><p>函数模版作用：建立一个通用函数 其函数返回值类型和形参类型可以不具体制定 用一个虚拟的类型来代表。</p>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>template –声明创建模版</p>
<p>typename  –表面其后面的符号是一种数据类型 可以用class代替</p>
<p>T –通用的数据类型名称可以替换 通常为大写字母</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//声明一个模版 告诉编译器我们后面的代码中紧跟着的T不要报错 T是一个通用的数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//两种方式使用函数模版</span></span><br><span class="line">    <span class="comment">//1 自动类型推导</span></span><br><span class="line">    <span class="built_in">mySwap</span>(a,b);</span><br><span class="line">    <span class="comment">//2 显示指定类型</span></span><br><span class="line">    <span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数模版注意事项"><a href="#函数模版注意事项" class="headerlink" title="函数模版注意事项"></a>函数模版注意事项</h4><p>注意事项：</p>
<ul>
<li>自动类型推导 必须推导出一致的数据类型T 才可以使用</li>
<li>模版必须要确定出T的数据类型才可以使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模版必须确定出数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">20</span>;</span><br><span class="line">   <span class="comment">//mySwap(a,b);推导不出一致的T的类型</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;();<span class="comment">//必须显示规定类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数模版案例"><a href="#函数模版案例" class="headerlink" title="函数模版案例"></a>函数模版案例</h4><p>案例描述：</p>
<ul>
<li>利用函数模版封装一个排序的函数 可以对不同数据类型数组进行排序</li>
<li>排序规则从小到大 排序算法为选择排序</li>
<li>分别利用char数组和int数组进行测试</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现一个通用的对数组进行排序的函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="type">int</span> max = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[max] &lt; arr[j])&#123;</span><br><span class="line">                max = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max != i)&#123;</span><br><span class="line">            <span class="comment">//交换max和i下标的元素</span></span><br><span class="line">            <span class="built_in">mySwap</span>(arr[max],arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> charArr[] = <span class="string">&quot;badcfe&quot;</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr)/<span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">    <span class="built_in">mySort</span>(charArr,num);</span><br><span class="line">    <span class="built_in">printArray</span>(charArr,num);</span><br><span class="line">    <span class="type">int</span> intArr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(intArr)/<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">mySort</span>(intArr,len);</span><br><span class="line">    <span class="built_in">printArray</span>(intArr,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a,T&amp; b)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="普通函数和函数模版的区别"><a href="#普通函数和函数模版的区别" class="headerlink" title="普通函数和函数模版的区别"></a>普通函数和函数模版的区别</h4><p>普通函数与函数模版区别：</p>
<ul>
<li>普通函数调用时可以发生自动类型转换</li>
<li>函数模版调用时 如果利用自动类型推导 不会发生隐式类型转换</li>
<li>如果利用显示指定的方式 可以发生隐式类型转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;<span class="comment">// &#x27;a&#x27; - 97</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd01</span>(a,c) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动类型推导</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd02</span>(a,b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示指定类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a,c) &lt;&lt; endl; <span class="comment">//109</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd02</span>&lt;<span class="type">char</span>&gt;(a,c) &lt;&lt; endl; <span class="comment">//m</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>建议使用显示指定类型的方式调用函数模版</p>
<h4 id="普通函数和函数模版的调用规则"><a href="#普通函数和函数模版的调用规则" class="headerlink" title="普通函数和函数模版的调用规则"></a>普通函数和函数模版的调用规则</h4><p>注意普通函数和函数模版的名可以是一样的。</p>
<p>调用规则如下：</p>
<ol>
<li>如果函数模版和普通函数都可以调用 优先调用普通函数</li>
<li>可以通过空模版参数列表来强制调用函数模版</li>
<li>函数模版可以发生重载</li>
<li>如果函数模版可以发生更好的匹配 优先调用函数模版</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的是普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的是函数模版&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a,T b,T c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的是重载函数模版&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//如果函数有实现调用的是普通函数 如果函数没有实现会报错 &quot;无法解析的外部命令&quot;</span></span><br><span class="line">    <span class="built_in">myPrint</span>(a,b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过空模版参数列表 强制调用函数模版</span></span><br><span class="line">    myPrint&lt;&gt;(a,b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数模版可以发生重载</span></span><br><span class="line">    <span class="built_in">myPrint</span>(a,b,c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果函数模版可以产生更好的匹配 优先调用函数模版</span></span><br><span class="line">    <span class="type">char</span> c1 = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> c2 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(c1,c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：既然提供了函数模版 尽量就不要提供普通函数了</p>
<h4 id="模版的局限性"><a href="#模版的局限性" class="headerlink" title="模版的局限性"></a>模版的局限性</h4><p>例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码如果传入的a和b是一个数组 就无法实现了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传入的是Person这样的自定义数据类型 也无法正常运心</p>
<p>因此c++为了解决这种问题 提供模版的函数 可以为这些特定的类型提供具体化的模版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对比两个数据是否相等的函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用具体化Person版本实现代码 具体化优先调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person&amp; a,Person&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.m_Age == b.m_Age &amp;&amp; a.m_Name == b.m_Name)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1,p2);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a,b);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对比两个数据是否相等的函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用具体化Person版本实现代码 具体化优先调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person&amp; a,Person&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.m_Age == b.m_Age &amp;&amp; a.m_Name == b.m_Name)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1,p2);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a,b);</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>学习模版并不是为了写模版 而是在STL能够运用系统提供的模版</li>
</ul>
<h3 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h3><h4 id="类模版语法"><a href="#类模版语法" class="headerlink" title="类模版语法"></a>类模版语法</h4><p>类模版作用：</p>
<ul>
<li>建立一个通用类 类中的成员 数据类型可以不具体制定 用一个虚拟的类型来代表</li>
</ul>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>,<span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name,AgeType age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">99</span>)</span></span>;<span class="comment">//&lt;&gt;叫做模版的参数列表</span></span><br><span class="line">    p1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模版和函数模版语法相似 在声明模版template后面加类，此类称为类模版</p>
<h4 id="类模版和函数模版的区别"><a href="#类模版和函数模版的区别" class="headerlink" title="类模版和函数模版的区别"></a>类模版和函数模版的区别</h4><p>类模版和函数模版的区别：</p>
<ol>
<li>类模版没有自动类型推导的使用方式</li>
<li>类模版在模版参数列表中可以有默认参数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>,<span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; <span class="comment">// AgeType默认为int</span></span><br><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name,AgeType age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">    NameType m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//无法用自动类型推导</span></span><br><span class="line">    <span class="comment">//Person p(&quot;孙悟空&quot;,100);</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">999</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用默认类型</span></span><br><span class="line">    <span class="function">Person&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模版中的成员函数创建时机"><a href="#类模版中的成员函数创建时机" class="headerlink" title="类模版中的成员函数创建时机"></a>类模版中的成员函数创建时机</h4><p>类模版中成员函数和普通成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模版中的成员函数在调用时才创建</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类模版中成员函数在调用时才去创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T obj;</span><br><span class="line">    <span class="comment">//类模版中的成员函数 需要确定的类型之后才能确定能不能调用 此时再创建</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj.<span class="built_in">showPerson1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        obj.<span class="built_in">showPerson2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyClass&lt;Person1&gt; m;</span><br><span class="line">    m.<span class="built_in">func1</span>();</span><br><span class="line">    <span class="comment">//m.func2();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模版对象做函数参数"><a href="#类模版对象做函数参数" class="headerlink" title="类模版对象做函数参数"></a>类模版对象做函数参数</h4><p>一共有三种传入方式：</p>
<ol>
<li>指定传入类型 –直接显示对象的数据类型</li>
<li>参数模版化    –将对象中的参数变为模版进行传递</li>
<li>整个类模版化 –将这个对象类型 模版化进行传递</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name,T2 age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1.制定传入类型 直接传入模版参数类标 第一种是最常见也是最推荐的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string,<span class="type">int</span>&gt;&amp; p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.将参数模版化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt;&amp; p)</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T1的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T2的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>,<span class="number">99</span>);</span><br><span class="line">    <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.将整个类都模版化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T&amp; p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T的数据类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模版与继承"><a href="#类模版与继承" class="headerlink" title="类模版与继承"></a>类模版与继承</h4><p>当类模版碰到继承时需要注意以下几点：</p>
<ul>
<li>当子类继承的父类是一个模版时 子类在声明的时候 要制定出父类中的T的类型</li>
<li>如果不制定 编译器无法给子类分配内存</li>
<li>如果想灵活制定出父类中T的类型 子类也需要变为类模版</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//必须要知道父类中T的数据类型才能继承给子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son s1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果想灵活的制定父类中T的类型 子类也需要变成类模版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&lt;T1&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son2</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;T1的数据类型是：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">//int</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;T2的数据类型是：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">//char</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Size of Son2:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son2) &lt;&lt; endl; <span class="comment">//8</span></span><br><span class="line">    &#125;</span><br><span class="line">    T2 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son2&lt;<span class="type">int</span>,<span class="type">char</span>&gt; s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模版成员函数类外实现"><a href="#类模版成员函数类外实现" class="headerlink" title="类模版成员函数类外实现"></a>类模版成员函数类外实现</h4><ul>
<li>类模版中成员函数类外实现时 需要加上模版参数列表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name,T2 age);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1,T2&gt;::<span class="built_in">Person</span>(T1 name,T2 age)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1,T2&gt;::<span class="built_in">showPerson</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模版分文件编写"><a href="#类模版分文件编写" class="headerlink" title="类模版分文件编写"></a>类模版分文件编写</h4><p>问题：</p>
<ul>
<li>类模版中成员函数的创建时机是在调用阶段 导致分文件编写时链接不到</li>
</ul>
<p>两种解决：</p>
<ol>
<li>直接包含.cpp文件</li>
<li>将声明和实现写到同一个文件中，并更改后缀名为.hpp, hpp是约定的名称 并不是强制</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种解决方法 直接包含源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种解决方法 将.h和.cpp中的内容写到一起 将后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：主流的解决方法是第二种 将类模版成员函数写到一起</p>
<h4 id="类模版与友元"><a href="#类模版与友元" class="headerlink" title="类模版与友元"></a>类模版与友元</h4><ul>
<li>全局函数类内实现 –直接在类内声明友元即可</li>
<li>全局函数类外实现 –需要提前让编译器知道全局函数的存在</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提前让编译器知道Person类的存在</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"><span class="comment">//类外实现的内容 提前让编译器知道 </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt; p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; p.m_Name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过全局函数 打印Person信息</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//全局函数 类内实现</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1,T2&gt; p)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; p.m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//全局函数 类外实现 普通函数</span></span><br><span class="line">    <span class="comment">//加一个空模版参数列表</span></span><br><span class="line">    <span class="comment">//如果全局函数是类外实现的话 需要让编译器提前知道这个函数的存在</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1,T2&gt; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name,T2 age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：建议全局函数做类内实现 用法简单 而且编译器可以直接识别</p>
<h4 id="类模版案例"><a href="#类模版案例" class="headerlink" title="类模版案例"></a>类模版案例</h4><ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">MyArray</span>(<span class="type">const</span> MyArray&amp; arr)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[arr.m_Capacity];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//operator=</span></span><br><span class="line">    MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray&amp; arr)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator=的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[arr.m_Capacity];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push_Back</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Size == <span class="keyword">this</span>-&gt;m_Capacity) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = value;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pop_Back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size--;<span class="comment">//逻辑尾删</span></span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="keyword">this</span>-&gt;m_Size &amp;&amp; index &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyArray</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">            pAddress = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* pAddress;</span><br><span class="line">    <span class="type">int</span> m_Capacity;</span><br><span class="line">    <span class="type">int</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">arr1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        arr1.<span class="built_in">Push_Back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printIntArray</span>(arr1);</span><br><span class="line">    cout &lt;&lt; arr1.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; arr1.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h2><h3 id="STL的诞生"><a href="#STL的诞生" class="headerlink" title="STL的诞生"></a>STL的诞生</h3><ul>
<li>c++的面向对象和泛型编程思想 目的就是复用性的提升</li>
<li>为了建立数据结构和算法的一套标准，诞生了STL</li>
</ul>
<h3 id="STL的基本概念"><a href="#STL的基本概念" class="headerlink" title="STL的基本概念"></a>STL的基本概念</h3><ul>
<li>STL standar template library</li>
<li>STL从广义上分为 容器 container 算法 algorithm 迭代器iterator</li>
<li>容器和算法之间通过迭代器进行无缝连接</li>
</ul>
<h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><ol>
<li>容器：各种数据结构 vector、list、deque、set、map</li>
<li>算法：常用算法 sort、find、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂</li>
<li>仿函数：行为类似函数 可作为算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器借口的东西</li>
<li>空间配置器：负责空间的配置与管理</li>
</ol>
<p>##STL中容器、算法、迭代器</p>
<p>容器分为序列容器和关联式容器两种：</p>
<ul>
<li>序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置</li>
<li>关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系</li>
</ul>
<p>算法分为：质变算法和非质变算法</p>
<ul>
<li>质变算法：是指运算过程中会更改区间内的元素的内容，例如拷贝、替换、删除</li>
<li>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</li>
</ul>
<p>迭代器：<strong>算法要通过迭代器访问容器中的元素</strong> 容器和算法之间的粘合剂</p>
<ul>
<li>提供一种方法 使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式</li>
<li>每个容器都有属于自己专属的迭代器</li>
<li>迭代器使用非常类似指针 初学阶段我们可以先理解迭代器为指针</li>
</ul>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入</td>
<td>对数据的只读访问</td>
<td></td>
</tr>
<tr>
<td>输出</td>
<td>对数据的只写访问</td>
<td></td>
</tr>
<tr>
<td>前向</td>
<td>读写操作，并能向前推进迭代器</td>
<td></td>
</tr>
<tr>
<td>双向</td>
<td>读写操作，并能向前和向后操作</td>
<td></td>
</tr>
<tr>
<td>随机访问</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td></td>
</tr>
</tbody></table>
<p>常用的容器中迭代器种类为双向迭代器 随机访问迭代器。</p>
<h3 id="STL-常见容器"><a href="#STL-常见容器" class="headerlink" title="STL-常见容器"></a>STL-常见容器</h3><h4 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h4><h5 id="string基本概念"><a href="#string基本概念" class="headerlink" title="string基本概念"></a>string基本概念</h5><p>本质：</p>
<ul>
<li>string是c++风格的字符串，而string本质上是一个类</li>
</ul>
<p>string和char*区别：</p>
<ul>
<li>char*是一个指针</li>
<li>string是一个类 类内部封装了char *，管理这个字符串，是一个char *类型容器</li>
</ul>
<p>特点：</p>
<ul>
<li>string类内部封装了很多成员方法 例如：查找find 拷贝copy 删除delete 替换replace 插入insert</li>
<li>string管理char *所分配的内存，不用担心赋值越界和取值越界等，由类内部进行负责</li>
</ul>
<h5 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h5><p>构造函数原型：</p>
<ul>
<li>string（）//创建一个空的字符串</li>
<li>string(const char* s) //使用字符串s初始化</li>
<li>string(const string&amp; str) //使用一个string对象初始化另一个string对象</li>
<li>string(int n, char c) //使用n个字符c初始化</li>
</ul>
<h5 id="string的赋值操作"><a href="#string的赋值操作" class="headerlink" title="string的赋值操作"></a>string的赋值操作</h5><p>赋值的函数原型：</p>
<ul>
<li>string&amp; operator=(const char* s) //char*类型字符串 赋值给当前的字符串</li>
<li>string&amp; operator=(const string&amp; s) // 把字符串s赋给当前的字符串</li>
<li>string&amp; operatot=(char c) //把字符赋给当前的字符串</li>
<li>string&amp;  assign(const char* s) //把字符串s赋给当前的字符串</li>
<li>string&amp; assign(const char* s,int n) // 把字符串s的前n个字符赋给当前的字符串</li>
<li>string&amp; assing(const string&amp; s) //把字符串s赋给当前字符串</li>
<li>string&amp; assign(int n,char c) //用n个字符c赋给当前字符串</li>
</ul>
<h5 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h5><p>拼接的函数原型：</p>
<ul>
<li>string&amp; operator+=(const char* str) //重载+=操作符</li>
<li>string&amp; operator+=(const char c) //重载+=操作符</li>
<li>string&amp; operator+=(const string&amp; str) //重载+=操作符</li>
<li>string&amp; append(const char* s) //把字符串s连接到当前字符串结尾</li>
<li>string&amp; append(const char* s,int n) //把字符串s的前n个字符连接到当前字符串结尾</li>
<li>string&amp; append(const string&amp; s) //同operator+=(const string&amp; str)</li>
<li>string&amp; append(const string &amp;s,int pos,int n) //字符串s中从pos开始的n个字符连接到字符串结尾 </li>
</ul>
<h4 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h4><p>查找：查找制定字符串是否存在</p>
<p>替换：在指定的位置替换字符串</p>
<p>函数原型：</p>
<ul>
<li>int find(const string&amp; str,int pos = 0) const; //查找str第一次出现的位置，从pos开始查找</li>
<li>int find(const char* s,int pos =0) const; //查找s</li>
<li>int find(const char* s,int pos,int n) const;</li>
</ul>
<h5 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h5><p>比较方式：按字符的ASCII码进行比较</p>
<p>= 返回 0   &gt; 返回 1  &lt; 返回 -1</p>
<p>函数原型：</p>
<ul>
<li>int compare(const string&amp; s) const;</li>
<li>int compare(const char* s) const;</li>
</ul>
<h5 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h5><p>string中单个字符存取方式有两种</p>
<ul>
<li>char&amp; operator[](int n);</li>
<li>char&amp; at(int n);</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="comment">//获取单个字符</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//修改单个字符</span></span><br><span class="line">  str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h5><p>函数原型：</p>
<ul>
<li>string&amp; insert(int pos,const char* s) // 插入字符串</li>
<li>string&amp; insert(int pos,const string&amp; str) //插入字符串</li>
<li>string&amp; insert(int pos,int n,char c) //在指定位置插入n个字符c</li>
<li>string&amp; erase(int pos, int n = npos) //删除从pos开始的n个字符</li>
</ul>
<h5 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h5><p>函数原型：</p>
<ul>
<li>string substr(int pos = 0; int n = npos) const //返回从pos开始的n个子字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  string email = <span class="string">&quot;zhangsan@sina.com&quot;</span>;</span><br><span class="line">  <span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">  string userName = email.<span class="built_in">substr</span>(<span class="number">0</span>,pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h4><ul>
<li>vector和数组很相似也称为单端数组</li>
<li>vector和普通数组不同之处在于vector可以动态扩展</li>
<li>动态扩展并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间</li>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h5 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h5><p>函数原型：</p>
<ul>
<li><p>vector<T> v; //默认构造</p>
</li>
<li><p>vector(v.begin( ),v.end( )); //将v[begin(),end())区间中的元素拷贝给本身</p>
</li>
<li><p>vector(n,elem); //构造函数将n个elem拷贝给本身</p>
</li>
<li><p>vector(const vector&amp; vec) //拷贝构造函数</p>
</li>
<li><p>容器：vector</p>
<p>算法：for_each</p>
<p>迭代器：vector<int>::iterator  vector<Person>::iterator </p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过迭代器访问容器中的数据</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itBegin = v.<span class="built_in">begin</span>();<span class="comment">//指向第一个位置</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator itEnd = v.<span class="built_in">end</span>();<span class="comment">//指向最后一个的下一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(itBegin != itEnd)&#123;</span><br><span class="line">        cout &lt;&lt; *itBegin &lt;&lt; endl;</span><br><span class="line">        itBegin++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vector容器的嵌套</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        v3.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++)&#123;</span><br><span class="line">            cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h5><p>函数原型：</p>
<ul>
<li>vector&amp; operator=(const vector &amp;vec)</li>
<li>assign(beg,end)</li>
<li>assign(n,elem)</li>
</ul>
<h5 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h5><p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">* <span class="built_in">empty</span>() <span class="comment">//判断容器是否为空</span></span><br><span class="line">* <span class="built_in">capacity</span>() <span class="comment">//容器的容量</span></span><br><span class="line">* <span class="built_in">size</span>() <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">* <span class="built_in">resize</span>(<span class="type">int</span> num) <span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置，若容器变短，则尾部超出容器长度的元素被删除</span></span><br><span class="line">* <span class="built_in">resize</span>(<span class="type">int</span> num,elem) <span class="comment">//重新指定容器的长度为num，若容器变长，则以elem填充新位置，若容器变短，则尾部超出容器长度的元素被删除</span></span><br></pre></td></tr></table></figure>

<h5 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h5><p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">* <span class="built_in">push_back</span>(elem); <span class="comment">//尾部插入元素elem</span></span><br><span class="line">* <span class="built_in">pop_back</span>( ); <span class="comment">//删除最后一个元素</span></span><br><span class="line">* <span class="built_in">insert</span>(const_iterator pos,elem); <span class="comment">//迭代器指向位置pos插入elem 注意一定是迭代器</span></span><br><span class="line">* <span class="built_in">insert</span>(const_iterator pos,<span class="type">int</span> count,elem); <span class="comment">//迭代器指向pos插入count个元素elem</span></span><br><span class="line">* <span class="built_in">erase</span>(const_iterator pos); <span class="comment">//删除迭代器指向的元素</span></span><br><span class="line">* <span class="built_in">erase</span>(const_iterator start,const_iterator end); <span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line">* <span class="built_in">clear</span>( ); <span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure>



<h5 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取"></a>vector数据存取</h5><p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">* <span class="built_in">at</span>(<span class="type">int</span> idx) <span class="comment">//返回索引idx所指的数据</span></span><br><span class="line">* <span class="keyword">operator</span>[ ] <span class="comment">//返回索引idx所指的数据</span></span><br><span class="line">* <span class="built_in">front</span>( ) <span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line">* <span class="built_in">back</span>( ) <span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure>

<h5 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器"></a>vector互换容器</h5><p>函数原型：</p>
<ul>
<li>swap(vec) //将vec与本身进行交换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">  cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">//容量不会变</span></span><br><span class="line">  cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//大小会变 浪费！</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//巧用swap收缩内存</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v); </span><br><span class="line">  cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line">  cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a>vector预留空间</h5><p>功能：可以减少vector在动态扩展容量时的扩展次数</p>
<p>函数原型：</p>
<ul>
<li>reserve(int len) //预留len个空间</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">  <span class="comment">//利用reserve预留空间</span></span><br><span class="line">  v.<span class="built_in">reserve</span>(<span class="number">10000000</span>);</span><br><span class="line">  <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != &amp;v[<span class="number">0</span>])&#123;</span><br><span class="line">      p = &amp;v[<span class="number">0</span>];</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back"></a>emplace_back</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h4><h5 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h5><ul>
<li>双端数组：可以对头端进行插入删除</li>
<li>vector对头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度会比vector快</li>
<li>vector访问元素时的速度会比deque快，这和两者内部实现有关</li>
</ul>
<p>deque内部工作原理：</p>
<ul>
<li>deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据</li>
<li>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</li>
</ul>
<h5 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h5><p>函数原型：                                                                                                                                                                          </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque&lt;T&gt; deqT; <span class="comment">//</span></span><br><span class="line"><span class="built_in">deque</span>(begin,end); <span class="comment">//构造函数将[beg,end)区间中的元素拷贝给本身</span></span><br><span class="line"><span class="built_in">deque</span>(n,elem); <span class="comment">//构造函数将n个elem拷贝给本身</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque&amp; deq); <span class="comment">//拷贝构造函数                 </span></span><br></pre></td></tr></table></figure>

<h5 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h5><p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque&amp; <span class="keyword">operator</span>=(<span class="type">const</span> deque&amp; deq);</span><br><span class="line"><span class="built_in">assign</span>(beg,end);</span><br><span class="line"><span class="built_in">assign</span>(n,elem);</span><br></pre></td></tr></table></figure>

<h5 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h5><p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque.<span class="built_in">empty</span>();</span><br><span class="line">deque.<span class="built_in">size</span>();</span><br><span class="line">deque.<span class="built_in">resize</span>(num);</span><br><span class="line">deque.<span class="built_in">resize</span>(num,size);</span><br></pre></td></tr></table></figure>





<h4 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h4><p>简介</p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p>本质</p>
<ul>
<li>属于关联式容器 底层结构是用二叉树实现的</li>
</ul>
<p>#####set的构造和赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt;&amp; s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> ite = s.<span class="built_in">begin</span>(); ite != s.<span class="built_in">end</span>(); ite++)&#123;</span><br><span class="line">    cout &lt;&lt; *ite &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//所有元素插入时候自动被排序</span></span><br><span class="line">  <span class="comment">//set容器不允许插入重复值</span></span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);  </span><br><span class="line">  </span><br><span class="line">  set&lt;<span class="type">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">  </span><br><span class="line">  set&lt;<span class="type">int</span>&gt;s3</span><br><span class="line">  s3 = s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="set插入和删除"><a href="#set插入和删除" class="headerlink" title="set插入和删除"></a>set插入和删除</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt;&amp; s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> ite = s.<span class="built_in">begin</span>(); ite != s.<span class="built_in">end</span>(); ite++)&#123;</span><br><span class="line">    cout &lt;&lt; *ite &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);  </span><br><span class="line">  </span><br><span class="line">  s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line">  s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">  </span><br><span class="line">  s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">end</span>());</span><br><span class="line">  s1.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="set容器的查找和统计"><a href="#set容器的查找和统计" class="headerlink" title="set容器的查找和统计"></a>set容器的查找和统计</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> test&#123;</span><br><span class="line">  set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">  pair&lt;set&lt;<span class="type">int</span>&gt;::iterator,<span class="type">bool</span>&gt; ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(ret.second) cout &lt;&lt; <span class="string">&quot;success&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  pair&lt;string,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">20</span>);</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; p.first &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  pair&lt;string,<span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">30</span>);</span><br><span class="line">  cout &lt;&lt; p2.first &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="set容器的排序"><a href="#set容器的排序" class="headerlink" title="set容器的排序"></a>set容器的排序</h5><ul>
<li>内置数据类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mycompare</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  set&lt;<span class="type">int</span>,Mycompare&gt; s1;</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义数据类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//设置成friend</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Person&amp; p1,<span class="type">const</span> Person&amp; p2)&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.m_Age &lt; p2.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1,<span class="type">const</span> Person&amp; p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.m_Age &lt; p2.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//自定义数据类型需要指定排序规则</span></span><br><span class="line">    <span class="comment">//或者set&lt;Person&gt; s1</span></span><br><span class="line">    set&lt;Person&gt; s;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>,<span class="number">21</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;Jack&quot;</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="map-multimap-容器"><a href="#map-multimap-容器" class="headerlink" title="map/multimap 容器"></a>map/multimap 容器</h4><p>简介</p>
<ul>
<li>map里面所有元素都是pair</li>
<li>pair中第一个元素是key 第二个元素是value</li>
<li>所有元素都会根据元素的key值自动排序</li>
</ul>
<p>本质</p>
<ul>
<li>map/multimap 属于关联式容器，底层是用二叉树实现的</li>
</ul>
<p>优点</p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>区别</p>
<ul>
<li>map中不允许有重复的key值元素</li>
<li>multimap允许有重复的key值元素</li>
</ul>
<h5 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> ite = m.<span class="built_in">begin</span>(); ite != m.<span class="built_in">end</span>(); ite++)&#123;</span><br><span class="line">    cout &lt;&lt; (*ite).first &lt;&lt; ite-&gt;second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line">  map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;<span class="built_in">m2</span>(m);</span><br><span class="line">  <span class="built_in">printMap</span>(m2);</span><br><span class="line">  map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m3 = m2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">size</span>();</span><br><span class="line">m.<span class="built_in">swap</span>(m2);</span><br></pre></td></tr></table></figure>

<h5 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> ite = m.<span class="built_in">begin</span>(); ite != m.<span class="built_in">end</span>(); ite++)&#123;</span><br><span class="line">    cout &lt;&lt; (*ite).first &lt;&lt; ite-&gt;second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">  </span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="number">20</span>));</span><br><span class="line">  </span><br><span class="line">  m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>,<span class="number">30</span>));</span><br><span class="line">  </span><br><span class="line">  m[<span class="number">4</span>] = <span class="number">40</span>;<span class="comment">//不建议插入 可以利用key访问</span></span><br><span class="line">  </span><br><span class="line">  m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">  m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">  m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">  m.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="map的查找和统计"><a href="#map的查找和统计" class="headerlink" title="map的查找和统计"></a>map的查找和统计</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> test01&#123;</span><br><span class="line">  map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m;</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">30</span>));</span><br><span class="line">  map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>); <span class="comment">//key = 3</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(pos != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">    cout &lt;&lt; pos-&gt;first &lt;&lt; pos-&gt;second &lt;&lt; endl;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not find&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">  cout &lt;&lt; num &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="map容器排序"><a href="#map容器排序" class="headerlink" title="map容器排序"></a>map容器排序</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mycompare</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  map&lt;<span class="type">int</span>,<span class="type">int</span>,Mycompare&gt; m;</span><br><span class="line">  </span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">30</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">4</span>,<span class="number">40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><h5 id="unordered-map对自定义类型的HASH运算"><a href="#unordered-map对自定义类型的HASH运算" class="headerlink" title="unordered_map对自定义类型的HASH运算"></a>unordered_map对自定义类型的HASH运算</h5><p>对于unordered_map而言，当我们插入&lt;key, value&gt;的时候，需要哈希函数的函数对象对key进行hash，又要利用等比函数的函数对象确保插入的键值对没有重复。然而，当我们自定义类型时，c++标准库并没有对应的哈希函数和等比函数的函数对象。因此需要分别对它们进行定义。</p>
<p>因为都是函数对象，它们两个的实际定义方法并没有很大差别。不过后者比前者多了一个方法。因为等比函数的函数对象默认值std::equal_to<key>内部是通过调用操作符”==” 进行等值判断,因此我们可以直接在自定义类里面进行operator==( )重载（成员和友元都可以）。</p>
<p>因此，如果要将自定义类型作为unordered_map的键值，需如下两个步骤：</p>
<ul>
<li><p>定义哈希函数的函数对象；</p>
</li>
<li><p>定义等比函数的函数对象或者在自定义类里重载operator==()。</p>
</li>
</ul>
<p>下面是对unordered_map的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Ty</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Hash</span> = std::hash&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Pred = std::equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="keyword">class</span> Alloc = std::allocator&lt;std::pair&lt;<span class="type">const</span> Key, Ty&gt; &gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> unordered_map;</span><br><span class="line">    &gt; <span class="keyword">class</span> <span class="title class_">unordered_map</span></span><br><span class="line">      </span><br><span class="line">第<span class="number">1</span>个参数，存储key值。</span><br><span class="line"></span><br><span class="line">第<span class="number">2</span>个参数，存储mapped value。</span><br><span class="line"></span><br><span class="line">第<span class="number">3</span>个参数，为哈希函数的函数对象。它将key作为参数，并利用函数对象中的哈希函数返回类型为<span class="type">size_t</span>的唯一哈希值。默认值为std::hash&lt;key&gt;。</span><br><span class="line"></span><br><span class="line">第<span class="number">4</span>个参数，为等比函数的函数对象。它内部通过等比操作符<span class="string">&quot;==&quot;</span>来判断两个key是否相等，返回值为<span class="type">bool</span>类型。默认值是std::equal_to&lt;key&gt;。在unordered_map中，任意两个元素之间始终返回<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>我们先来学习一下如何构造一个对自定义类型进行hash的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">//在该头文件中定义了无序关联容器使用的特例化hash&lt;K&gt;模版。hash&lt;K&gt;模版定义了可以从K类型的对象生成哈希值的函数对象的类型</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="type">int</span> age):<span class="built_in">m_name</span>(name),<span class="built_in">m_age</span>(age)&#123;&#125;;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (m_age == rhs.m_age &amp;&amp; m_name == rhs.m_name);</span><br><span class="line">    &#125;</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里是将自己写的偏特化也同样加入到std中，因为他的模板是在std里面的，</span></span><br><span class="line"><span class="comment">//具体形式可以自己简单查看一下源码中的实现形式</span></span><br><span class="line"><span class="comment">//然后照着写一个自己的版本就行了。</span></span><br><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;Person&gt;&#123;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; rhs)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(rhs.m_age) ^ (<span class="built_in">hash</span>&lt;string&gt;()(rhs.m_name) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    unordered_map&lt;Person,<span class="type">int</span>,std::hash&lt;Person&gt;&gt; map;</span><br><span class="line">    map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(p1,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另外针对侯捷老师的万能哈希函数我们可以设计出下面这个hash</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="built_in">Person</span>(string n,<span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a)&#123;&#125;;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; p) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name == p.name &amp;&amp; age ==p.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class PersonHash&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash_val</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line">  <span class="type">size_t</span> <span class="built_in">hash_val</span>(<span class="type">const</span> Types&amp;... args) <span class="type">const</span>&#123;</span><br><span class="line">     <span class="type">size_t</span> seed = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">hash_value</span>(seed, args...);</span><br><span class="line">     <span class="keyword">return</span> seed;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">hash_value</span><span class="params">(<span class="type">size_t</span>&amp; seed,<span class="type">const</span> T&amp; firstArg,<span class="type">const</span> Types&amp;... args)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed, firstArg);</span><br><span class="line">    <span class="built_in">hash_value</span>(seed, args...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">hash_value</span><span class="params">(<span class="type">size_t</span>&amp; seed,<span class="type">const</span> T&amp; val)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">hash_combine</span><span class="params">(<span class="type">size_t</span>&amp; seed,<span class="type">const</span> T&amp; val)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    seed ^= <span class="built_in">hash</span>&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span> + (seed &lt;&lt; <span class="number">6</span>) + (seed &gt;&gt; <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::unordered_multiset&lt;Customer,CustomerHash&gt; set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><h3 id="基本概念和使用"><a href="#基本概念和使用" class="headerlink" title="基本概念和使用"></a>基本概念和使用</h3><p>概念：</p>
<ul>
<li>重载函数调用操作符的类，其对象常称为函数对象</li>
<li>函数对象使用重载的()时候，行为类似函数调用，也叫仿函数</li>
</ul>
<p>本质：</p>
<ul>
<li>函数对象（仿函数）是一个类，不是一个函数</li>
</ul>
<p>函数对象的使用：</p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 + v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint&amp; mp,string test)</span></span>&#123;</span><br><span class="line">    <span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p>概念：</p>
<ul>
<li>返回bool类型的仿函数称为谓词</li>
<li>如果operator（）接受一个参数，那么就叫做一元谓词</li>
<li>如果operator（）接受两个参数，那么就叫做二元谓词</li>
</ul>
<h4 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">GreaterFive</span>());<span class="comment">//最后一个是匿名的函数对象</span></span><br><span class="line">  <span class="keyword">if</span>(it == v.<span class="built_in">end</span>()) cout &lt;&lt; <span class="string">&quot;not find&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;find!&quot;</span> &lt;&lt; *(it) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二元谓词"><a href="#二元谓词" class="headerlink" title="二元谓词"></a>二元谓词</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mycompare</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1,<span class="type">int</span> val2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//二元谓词</span></span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">Mycompare</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h3><p>分类：</p>
<ul>
<li>算术仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数</li>
</ul>
<p>用法：</p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件#include<functional></li>
</ul>
<h4 id="算术仿函数"><a href="#算术仿函数" class="headerlink" title="算术仿函数"></a>算术仿函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T plus&lt;T&gt; <span class="comment">//加法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">  plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">bool</span> <span class="title">logical_and</span><span class="params">(T)</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">bool</span> <span class="title">logical_or</span><span class="params">(T)</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">bool</span> <span class="title">logical_not</span><span class="params">(T)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"> <span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">  </span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">  v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),v2.<span class="built_in">begin</span>(),<span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h1><p>C++11包括大量的新特性，包括lambda表达式，类型推导关键字auto，decltype，和模板的大量改进</p>
<h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><ul>
<li>在C中，auto修饰局部变量，局部变量也叫auto变量，自动变量 int a = auto int a;</li>
<li>在C++中 auto根据用户初始化内容自动推导类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tmp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = tmp.<span class="built_in">begin</span>(); i &lt; tmp.<span class="built_in">end</span>(); i++)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">foo</span>();</span><br><span class="line">    Test str = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> d = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//1.定义变量时，必须初始化</span></span><br><span class="line">   <span class="keyword">auto</span> a;</span><br><span class="line">   a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//2.部分函数形参不支持auto变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> c)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.auto变量不能作为自定义类型的成员变量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> b = <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//4.不能够auto数组</span></span><br><span class="line">    <span class="keyword">auto</span> b[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">//5.模板实例化不能是auto</span></span><br><span class="line">    vector&lt;<span class="keyword">auto</span>&gt; b = &#123; <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###decltype</p>
<ul>
<li>简单认为auto的反函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="keyword">decltype</span>(i)j = <span class="number">0</span>;</span><br><span class="line">   cout &lt;&lt; <span class="built_in">typeid</span>(j).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="type">float</span> a;</span><br><span class="line">   <span class="type">double</span> b;</span><br><span class="line">   <span class="keyword">decltype</span>(a+b)c;</span><br><span class="line">   cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">   temp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">   temp.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">decltype</span>(temp.<span class="built_in">begin</span>()) k;</span><br><span class="line">   <span class="keyword">for</span>(k = temp.<span class="built_in">begin</span>(); k &lt; temp.<span class="built_in">end</span>(); k++)&#123;</span><br><span class="line">       cout &lt;&lt; *k &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//匿名类型的枚举变量</span></span><br><span class="line">   <span class="keyword">enum</span>&#123;OK,Error&#125; flag;</span><br><span class="line">   <span class="keyword">decltype</span>(flag) flag2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="追踪返回类型"><a href="#追踪返回类型" class="headerlink" title="追踪返回类型"></a>追踪返回类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>-&gt;<span class="type">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span>-&gt; <span class="title">decltype</span><span class="params">(a+b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mul</span><span class="params">(<span class="type">const</span> T1&amp; a,<span class="type">const</span> T2&amp; b)</span>-&gt; <span class="title">decltype</span><span class="params">(a * b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">1.21</span>;</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="built_in">mul</span>(a,b);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="易用性的改进"><a href="#易用性的改进" class="headerlink" title="易用性的改进"></a>易用性的改进</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="类内成员初始化"><a href="#类内成员初始化" class="headerlink" title="类内成员初始化"></a>类内成员初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//参数列表初始化</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i) : <span class="built_in">a</span>(i)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data1&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="type">int</span> data2 = <span class="number">1</span>;</span><br><span class="line">    A tmp&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    string name &#123;<span class="string">&quot;mike&quot;</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B obj;</span><br><span class="line">    cout &lt;&lt; obj.data2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; obj.data1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; obj.tmp.a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; obj.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Test</span> temp = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;mike&quot;</span>&#125;;<span class="comment">//c语言的列表初始化</span></span><br><span class="line">    <span class="comment">//c++</span></span><br><span class="line">    <span class="type">int</span> b = &#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="type">int</span> c&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型收窄"><a href="#类型收窄" class="headerlink" title="类型收窄"></a>类型收窄</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">char</span> b = a;<span class="comment">//可以的，数据类型收窄</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>,b);</span><br><span class="line">    <span class="type">int</span> c = <span class="number">1024</span>;<span class="comment">//错误的</span></span><br><span class="line">    <span class="type">char</span> d = &#123; c &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###基于范围的for循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> itr:a)&#123;</span><br><span class="line">        <span class="comment">//形参中的数组不是数组，是指针变量</span></span><br><span class="line">        <span class="comment">//必须要确定数组的大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> temp:a)&#123;</span><br><span class="line">        cout &lt;&lt; temp &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h3><p>c++11新增了static_assert 可用于在编译阶段对断言进行测试</p>
<p>静态断言的好处</p>
<ul>
<li>更早的报告错误，开发成本的降低</li>
<li>减少运行时开销</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">void</span>*) == <span class="number">4</span>,<span class="string">&quot;64位系统不支持&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="noexcept修饰符"><a href="#noexcept修饰符" class="headerlink" title="noexcept修饰符"></a>noexcept修饰符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数不能抛出任何异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###nullptr</p>
<p>nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的是int类型&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的是int*类型&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">nullptr</span>;<span class="comment">//只能赋值给指针变量</span></span><br><span class="line">    <span class="type">int</span>* p2 = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// func(NULL); //报错</span></span><br><span class="line">   <span class="keyword">if</span>(p == p2) cout &lt;&lt; <span class="string">&quot;equal&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###强类型枚举</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//Redefinition of enumerator &#x27;Ok&#x27; &amp; Error</span></span><br><span class="line"> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;Ok,Error&#125;;</span><br><span class="line"> <span class="keyword">enum</span> <span class="title class_">Status2</span> &#123;Ok,Error&#125;;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">sizeof</span>(Ok) &lt;&lt; endl;<span class="comment">//4</span></span><br><span class="line"><span class="comment">//强类型枚举,enum后面加上class或struct修饰</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span> &#123;Ok,Error&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status2</span> &#123;Ok,Error&#125;;</span><br><span class="line"><span class="comment">// Status flag1 = Ok;Error,必须枚举类型的作用域</span></span><br><span class="line">Status flag2 = Status::Ok;</span><br><span class="line"><span class="comment">//强类型枚举，可以指定成员变量的类型</span></span><br><span class="line"><span class="keyword">enum struct</span> <span class="title class_">Status3</span>:<span class="type">char</span>&#123;Ok,Error&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Status3::Ok) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。</p>
<p>这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时都计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">GetNum2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetNum3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//常量表达式，发生在编译阶段</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Expression is not an integral constant expression</span></span><br><span class="line">    <span class="comment">//枚举成员初始化必须是整型常量</span></span><br><span class="line">    <span class="comment">//enum &#123;e1 = GetNum(),e2&#125;; wrong</span></span><br><span class="line">    <span class="comment">//enum &#123;e1 = GetNum2(),e2&#125;; wrong</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;e1 = <span class="built_in">GetNum3</span>(),e2&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> tmp = <span class="built_in">GetNum3</span>();</span><br><span class="line">    <span class="keyword">enum</span> &#123;a1 = tmp,a2&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>constexpr的限制：</p>
<ul>
<li>return返回语句表达式中不能使用非常量表达式的函数、全局数据、且必须是一个常量表达式</li>
</ul>
<p>常量表达式的构造函数有一下限制(11才有限制，14之后已有extension)：</p>
<ul>
<li><p>函数体必须为空</p>
</li>
<li><p>初始化列表只能由常量表达式来赋值</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//constexpr</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Date</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m,<span class="type">int</span> d)</span>:year(y),month(m),day(d)&#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;year;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetMonth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;month;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> Date obj&#123;<span class="number">2017</span>,<span class="number">10</span>,<span class="number">10</span>&#125;;<span class="comment">//必须使用常量给构造函数传参</span></span><br><span class="line">    cout &lt;&lt; obj.<span class="built_in">GetYear</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户自定义字面量"><a href="#用户自定义字面量" class="headerlink" title="用户自定义字面量"></a>用户自定义字面量</h3><h3 id="原生字符串字面值"><a href="#原生字符串字面值" class="headerlink" title="原生字符串字面值"></a>原生字符串字面值</h3><p>原生字符串字面值使用户书写的字符串“所见即所得”。C++11中原生字符串的声明相当简单，只需在字符串前加入前缀，即字母R，并在引号中使用左右标识，就可以声明该字符串字面量为原生字符串了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">R&quot;(&quot;hello world&quot;\n)&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<h2 id="类的改进"><a href="#类的改进" class="headerlink" title="类的改进"></a>类的改进</h2><h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><p>c++11中允许派生类继承基类的非默认构造函数（即默认、赋值、移动构造函数除外）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        a = x;</span><br><span class="line">        b = y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//B(int x,int y):A(x,y)&#123;&#125;;</span></span><br><span class="line">    <span class="keyword">using</span> A::A;<span class="comment">//继承构造</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">obj</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>继承的构造函数只能初始化基类的成员变量，不能初始化派生类的成员变量</li>
<li>如果基类的构造函数被声明为私有，或者派生类是从基类中虚继承，那么不能继承构造函数</li>
<li>一旦使用继承构造函数，编译器不会再为派生类生成默认构造函数(存在例外 如果基类含有几个构造函数)</li>
</ul>
<h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><ul>
<li>如果一个类包含多个构造函数，C++ 11允许在一个构造函数中的定义中使用另一个构造函数，但这必须通过初始化列表进行操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//委托构造一定要通过初始化列表方式</span></span><br><span class="line">    <span class="built_in">Test</span>():<span class="built_in">Test</span>(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x):<span class="built_in">Test</span>(x,<span class="string">&#x27;b&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">char</span> x):<span class="built_in">Test</span>(<span class="number">11</span>,x)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x,<span class="type">char</span> y):<span class="built_in">a</span>(x),<span class="built_in">b</span>(y)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test obj;</span><br><span class="line">    <span class="function">Test <span class="title">obj1</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="继承控制：final和override"><a href="#继承控制：final和override" class="headerlink" title="继承控制：final和override"></a>继承控制：final和override</h3><ul>
<li>final阻止类的进一步派生和虚函数的进一步重写</li>
<li>override确保在派生类中声明的函数跟基类的虚函数有相同的签名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> <span class="keyword">final</span> &#123;&#125;; <span class="comment">// 此类不能被继承</span></span><br><span class="line"><span class="comment">//class D1: public B1 &#123;&#125;; // error!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  virtual void func() override // error! 指定了重写但实际并没重写,没有基类</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      cout &lt;&lt; __func__ &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; __func__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; __func__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span>      <span class="comment">// ok! 隐藏,由于没有重写同名函数B::f,在D中变为不可见</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hiding: &quot;</span> &lt;&lt;__func__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  virtual void f() override   // error! 指定了重写但实际并没重写,类型声明不完全相同</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      cout &lt;&lt; __func__ &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> <span class="comment">// ok! 指定了重写实际上也重写了，同时，指定为最终，后代类中不能再重写此虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; __func__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span> : <span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span>      <span class="comment">// ok! 重写B::f(),同时,由于没有重写D::f(int),在D2中变不可见</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; __func__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  virtual void fun() // error! 基类的此虚函数被指定为最终,不能被重写,虽然没有显示指定&quot;override&quot;</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      cout &lt;&lt; __func__ &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  virtual void fun() override // error! 基类的此虚函数被指定为最终，不能被重写</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      cout &lt;&lt; __func__ &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类默认函数的控制：default函数和delete函数"><a href="#类默认函数的控制：default函数和delete函数" class="headerlink" title="类默认函数的控制：default函数和delete函数"></a>类默认函数的控制：default函数和delete函数</h3><h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><ul>
<li>default只能修饰类中默认提供的成员函数：默认构造、拷贝构造、赋值运算符重载</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() =<span class="keyword">default</span>;<span class="comment">//让编译器提供一个默认的构造函数，效率比用户写的高</span></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> i)&#123;a = i;&#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>=<span class="keyword">default</span>;<span class="comment">//Error</span></span><br><span class="line">    <span class="built_in">Test2</span>(<span class="type">int</span> x) =<span class="keyword">default</span>;<span class="comment">//Error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span>&#123;</span><br><span class="line">    <span class="built_in">Test3</span>();</span><br><span class="line">    <span class="built_in">Test3</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">Test3::<span class="built_in">Test3</span>() =<span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; ) =<span class="keyword">delete</span>; <span class="comment">//拷贝构造函数 此函数被删除无法调用</span></span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test&amp;) =<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span> </span>=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test obj;</span><br><span class="line">    Test obj2 = obj;</span><br><span class="line">    obj2 = obj;</span><br><span class="line">    Test* obj3 = <span class="keyword">new</span> Test[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模版的别名"><a href="#模版的别名" class="headerlink" title="模版的别名"></a>模版的别名</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">//std::is_same</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> uint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> UINT;</span><br><span class="line"><span class="keyword">using</span> sint = <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::is_same 判断类型是否一致</span></span><br><span class="line">    <span class="comment">//这个结构体作用很简单，就是两个一样的类型会返回true</span></span><br><span class="line">    cout &lt;&lt; is_same&lt;uint, UINT&gt;::value &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数默认的模版参数"><a href="#函数默认的模版参数" class="headerlink" title="函数默认的模版参数"></a>函数默认的模版参数</h3> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>普通函数的默认参数</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">3</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>类模支持默认的模版参数</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">T2</span> = <span class="type">int</span>&gt; <span class="comment">//如果有默认那么右边的所有都必须要有默认的</span></span><br><span class="line"><span class="keyword">class</span> A&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span>函数模版带默认的模版参数</span><br><span class="line"> <span class="comment">//函数模版的模版默认参数就不一定</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T = <span class="type">int</span>,<span class="keyword">class</span> T2&gt; <span class="type">void</span> <span class="built_in">func2</span>(T a,T2 b)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>##可变参数的模版函数</p>
<p>###可变参数的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ...T&gt; <span class="comment">//T叫模版参数包</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T... args)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;</span><br><span class="line">&#125; <span class="comment">//args叫函数参数包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">char</span>,<span class="type">int</span>,<span class="type">char</span>*&gt;(<span class="string">&#x27;a&#x27;</span>,<span class="number">10</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数包的展开"><a href="#参数包的展开" class="headerlink" title="参数包的展开"></a>参数包的展开</h3><ul>
<li><p>递归方式展开</p>
<p>需要提供一个参数包展开的函数和一个递归终止函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//终止条件</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(T last)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; last &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可变参数的模版函数</span></span><br><span class="line"><span class="comment">//参数包展开函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span>... T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(T1 first,T2... last)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; first &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//递归调用函数本身</span></span><br><span class="line">    <span class="built_in">debug</span>(last...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 神奇的展开方式 */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(Args... args)</span></span>&#123;</span><br><span class="line">  (std::cout &lt;&lt; ... &lt;&lt; args);</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span>...(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非递归展开</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T tmp)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">(T ...args)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;(<span class="built_in">print</span>(args),<span class="number">0</span>)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">expand</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可变参数模版类"><a href="#可变参数模版类" class="headerlink" title="可变参数模版类"></a>可变参数模版类</h3><ul>
<li>继承方式展开包</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承方式展开可变参数模版类</span></span><br><span class="line"><span class="comment">//1.可变参数模版声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ...T&gt;<span class="keyword">class</span> <span class="title class_">Car</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//2.递归继承模版类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Head</span>,<span class="keyword">class</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&lt;Head,Tail...&gt; : <span class="keyword">public</span> Car&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="comment">//递归继承本身</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Car</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">typeid</span>(Head).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//3.边界条件</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">class</span> <span class="title class_">Car</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Car&lt;<span class="type">int</span>,<span class="type">char</span>*,<span class="type">double</span>&gt;&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>模版递归和特化方式展开参数包</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span>... last&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> first, <span class="type">int</span> ...last&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;first,last...&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> val = first * Test&lt;last...&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; Test&lt;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&gt;::val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h3><p>左值右值概念：</p>
<ul>
<li>左值：可取地址，有具体名字</li>
<li>右值：无法取地址或没有具体名字</li>
</ul>
<p>相对于左值，右值表示字面常量、表达式、函数的非引用返回值等。</p>
<p>左值引用、右值引用：</p>
<ul>
<li>左值引用是对一个左值进行引用的类型</li>
<li>右值引用是对一个右值进行引用的类型</li>
</ul>
<p>Common：都必须立即初始化、只是该对象的一个别名。</p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>####为什么需要移动语义</p>
<p>右值引用是用来支持转移语义的，转移语义可以将资源（堆，系统对象等）从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高c++应用程序的性能，临时对象的维护（创建和销毁）对性能有严重影响</p>
<h4 id="移动语义定义"><a href="#移动语义定义" class="headerlink" title="移动语义定义"></a>移动语义定义</h4><p>在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。</p>
<p>如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。</p>
<p> 普通的函数和操作符也可以利用右值引用操作符实现转移语义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">char</span>* tmp = <span class="string">&quot;abc&quot;</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Default Construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">        len = <span class="built_in">strlen</span>(tmp);</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; tmp)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp.str);</span><br><span class="line">    &#125;</span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; tmp)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Operator = &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(&amp;tmp == <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp.str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyString</span>(MyString &amp;&amp; t)&#123;</span><br><span class="line">        <span class="comment">//移动构造函数</span></span><br><span class="line">        str = t.str;<span class="comment">//拷贝地址，没有重新申请内存</span></span><br><span class="line">        len = t.len;</span><br><span class="line">        t.str = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyString</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Deconstruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> []str;</span><br><span class="line">            str = <span class="literal">NULL</span>;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">obj</span><span class="params">(<span class="string">&quot;Mike&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> obj; <span class="comment">//返回的是右值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyString&amp;&amp; tmp = <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转移赋值函数"><a href="#转移赋值函数" class="headerlink" title="转移赋值函数"></a>转移赋值函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">char</span>* tmp = <span class="string">&quot;abc&quot;</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Default Construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">        len = <span class="built_in">strlen</span>(tmp);</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; tmp)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp.str);</span><br><span class="line">    &#125;</span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; tmp)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Operator = &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(&amp;tmp == <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,tmp.str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动赋值函数 参数为非const的右值引用</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; tmp)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move = &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(&amp;tmp == <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        <span class="comment">//无需重新申请堆区内存空间</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = tmp.str;</span><br><span class="line">        tmp.str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyString</span>(MyString &amp;&amp; t)&#123;</span><br><span class="line">        <span class="comment">//移动构造函数</span></span><br><span class="line">        str = t.str;<span class="comment">//拷贝地址，没有重新申请内存</span></span><br><span class="line">        len = t.len;</span><br><span class="line">        t.str = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyString</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Deconstruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> []str;</span><br><span class="line">            str = <span class="literal">NULL</span>;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">obj</span><span class="params">(<span class="string">&quot;Mike&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> obj; <span class="comment">//返回的是右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几点需要注意：</p>
<ul>
<li>参数（右值）的符号必须是右值引用 &amp;&amp;</li>
<li>参数（右值）不可以是常量，因为我们需要修改右值</li>
<li>参数（右值）的资源链接和标记必须修改，否则右值的析构函数就会释放资源，转移到新对象的资源就无效了。</li>
</ul>
<p>对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率</p>
<h3 id="标准库函数-std-move"><a href="#标准库函数-std-move" class="headerlink" title="标准库函数 std::move"></a>标准库函数 std::move</h3><p>如果已知一个命名对象不再被使用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用，怎样做呢？标准库提供了函数std::move,这个函数以非常简单的方式讲左值引用转换为右值引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; r1 = <span class="number">1</span><span class="comment">//error</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; r2 = std::<span class="built_in">move</span>(a)<span class="comment">//OKx</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Std::move 是如何定义的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> &gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward"></a>完美转发 std::forward</h3><p>完美转发适用于这样的场景：需要将一组参数原封不动的传递给另一个函数</p>
<p>“原封不动”不仅仅是参数的值不变，在C++中，除了参数值之，还有以下两组属性，：左值/右值和const/non-const。完美转发就是在参数传递过程中，所有这些属性和参数值都不能改变，同时不产生额外的开销，就好像转发者不存在一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T&amp; tmp)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;const T&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; tmp)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">forward_val</span><span class="params">(T &amp;&amp;tmp)</span></span>&#123;</span><br><span class="line">    <span class="comment">//完美转发</span></span><br><span class="line">    <span class="built_in">func</span>(forward&lt;T&gt;(tmp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; b= <span class="number">1</span>;</span><br><span class="line">    forward_val(a);</span><br><span class="line">    forward_val(b);</span><br><span class="line">    forward_val(<span class="number">11</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; temp = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">//必须包含的头文件</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">Test</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  unique_ptr&lt;<span class="type">double</span>&gt; p1;</span><br><span class="line">  <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">  <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">11</span>))</span></span>;</span><br><span class="line">  <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">22</span>))</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;*up1 = &quot;</span> &lt;&lt; *up1 &lt;&lt; endl;<span class="comment">//重载了operator *（）</span></span><br><span class="line">  <span class="comment">//如果是无参，作用是显示释放堆区内容</span></span><br><span class="line">  up1.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="comment">//如果有参数，先释放原来堆区内容，重新给up1绑定一个新的堆区内容</span></span><br><span class="line">  up1.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">22</span>));</span><br><span class="line">  cout &lt;&lt; *up1 &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//释放了控制权，不释放堆内存</span></span><br><span class="line">  <span class="type">int</span> *p = up3.<span class="built_in">release</span>();</span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">    </span><br><span class="line">  &#123;<span class="function">unique_ptr&lt;Test&gt; <span class="title">up2</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;&#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  <span class="function">unique_ptr&lt;string&gt; <span class="title">s1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Stegosaurus&quot;</span>))</span></span>;</span><br><span class="line">  <span class="function">unique_ptr&lt;string&gt; <span class="title">s2</span><span class="params">(s1)</span></span>; <span class="comment">// 不支持拷贝</span></span><br><span class="line">  unique_ptr&lt;string&gt; s3;</span><br><span class="line">  s3 = s2; <span class="comment">//错误 不支持赋值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><ul>
<li>推荐使用make_shared而不是new 这样我们就能在分配对象的同时就将shared_ptr与之绑定，从而避免了无意中将同一块内存绑定到多个独立创建的shared_ptr上</li>
<li>不用混合使用普通指针和智能指针，当我们将一个shared_ptr绑定到一个普通指针的时候，我们就将内存的管理责任交给了这个shared_ptr 一旦这样做了我们就不应该再使用内置指针来访问shared_ptr所指向的内存了。</li>
<li>不要使用get初始化另一个智能指针或为智能指针赋值，这样会导致独立创建两个智能指针指向同一块内存</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">22</span>))</span></span>;</span><br><span class="line">  shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1;<span class="comment">//拷贝构造 有两个对象和堆区空间绑定</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//释放sp1,只是计数器-1，堆区的空间并没有释放</span></span><br><span class="line">  sp1.<span class="built_in">reset</span>();</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; *sp2 &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Error shared_ptr 不能隐式类型转换</span></span><br><span class="line">  shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>如果是普通指针（自定义的指针）而不是new分配的内存，需要自己提供deleter</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span>;</span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connection</span><span class="params">(connection* op)</span></span>&#123;<span class="built_in">disconnect</span>(*p);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination&amp; d)</span></span>&#123;</span><br><span class="line">  connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">  <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c,end_connection)</span></span>;</span><br><span class="line">  <span class="comment">//这样即使当f异常退出时，connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">11</span>))</span></span>;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p2 = p1;</span><br><span class="line"></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; wp = p1;</span><br><span class="line">cout &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">虽然不和堆区空间绑定，可以通过lock函数获取shared_ptr的对象</span><br><span class="line">  </span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = wp.<span class="built_in">lock</span>();</span><br><span class="line">cout &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; *wp &lt;&lt; endl; error 没有重载 * 和 -&gt;</span></span><br><span class="line"></span><br><span class="line">p1.<span class="built_in">reset</span>();</span><br><span class="line">p2.<span class="built_in">reset</span>();</span><br><span class="line">p3.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; tmp = wp.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span>(tmp == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;empty!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="闭包的实现"><a href="#闭包的实现" class="headerlink" title="闭包的实现"></a>闭包的实现</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包是带有上下文的函数。就是有状态的函数。什么叫“带上状态”意思就是这个闭包有属于自己的变量，这些个变量的值是创建闭包的时候设置的，并在调用闭包的时候，可以访问这些变量。</p>
<p>函数是代码，状态是一组变量，将代码和一组变量捆绑（bind），就形成了闭包。</p>
<p>闭包的状态捆绑，必须发生在运行时</p>
<h3 id="仿函数：重载operator（）"><a href="#仿函数：重载operator（）" class="headerlink" title="仿函数：重载operator（）"></a>仿函数：重载operator（）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i):<span class="built_in">r</span>(i)&#123;&#125;;</span><br><span class="line">    <span class="comment">//仿函数 重载operator（）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tmp + r;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title">Fun</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//调用仿函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">obj</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h3><p>c++中函数指针的用途非常广泛，例如回调函数、接口类的设计等，但函数指针始终不太灵活，它只能指向全局或静态函数，对于类成员函数、lambda表达式或其他可调用对象就无能为力了，而C++11推出了std::function 与 std::bind</p>
<h4 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> i + j;&#125;</span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="type">int</span> i,<span class="type">int</span> j)&#123;<span class="keyword">return</span> i % j;&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string,<span class="type">int</span>(*)(<span class="type">int</span>,<span class="type">int</span>)&gt; binops;</span><br><span class="line"></span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,add&#125;);</span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;%&quot;</span>,mod&#125;)；<span class="comment">//错误：mod不是一个函数指针</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用一个名为function的新的标准库类型解决上述问题。</p>
<h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><p>std::function 可以说是函数指针的超集，它除了可以指向全局和静态函数，还可以指向仿函数，lambda表达式，类成员函数，甚至函数签名（function::signature):包含一个函数的信息，包括函数名、参数类型、参数个数、顺序以及它所在的类和命名空间，普通函数签名并不包含函数返回值部分，可以说几乎所有可以调用的对象都可以当做std::function，当然对于后两个需要使用std::bind进行配合，而至于指向其他类型可以参考以下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span> ()&gt; PrintFinCallback;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text,PrintFinCallback callback)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,text);</span><br><span class="line">    <span class="keyword">if</span>(callback)</span><br><span class="line">        <span class="built_in">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFinCallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Normal callback&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printFinCallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Static callback&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Functor</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Functor callback&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test 1&quot;</span>,printFinCallback);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test 2&quot;</span>,Test::printFinCallback);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test 3&quot;</span>,<span class="built_in">Functor</span>());</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test 4&quot;</span>,[]()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lambda printCallback&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在c++中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象、以及重载了函数调用运算符的类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;T&gt; f</span><br><span class="line">f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数类型T相同</span><br><span class="line"></span><br><span class="line"><span class="function">function&lt;T&gt; <span class="title">f</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">显式构造一个空<span class="function">function</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">function&lt;T&gt; <span class="title">f</span><span class="params">(obj)</span></span>;</span><br><span class="line">在f中存储可调用对象obj的副本</span><br><span class="line"></span><br><span class="line">f</span><br><span class="line">将f作为条件，当f含有一个可调用对象时为真，否则为假</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(args)</span><br><span class="line">调用f中的对象 参数是args</span><br></pre></td></tr></table></figure>

<ul>
<li>tips 如果f是类的一个函数那么它必须是一个静态函数 因为成员函数并不是一个可调用的对象 </li>
<li>std::function 对象最大的用处就是在实现函数回调，使用这需要注意，它不能被用来检查相等或者不想等，但是可以与NULL或者nullptr进行比较</li>
</ul>
<h4 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h4><p>std::bind是这样一种机制，它可以预先把指定可调用实体的某些参数绑定到已有的变量，产生一个新的可调用实体，这种机制在回调函数的使用过程中也颇有用</p>
<p>在C++11中，提供了std::bind，它绑定的参数的个数不受限制，绑定的具体哪些参数也不受限制、由用户指定，这个bind才是真正意义上的绑定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">bind</span>(func,<span class="number">11</span>,<span class="number">22</span>)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//占位符 std::placeholders::_1 函数调用时被第一个参数替换</span></span><br><span class="line">    <span class="comment">//      std::placeholders::_2 函数调用时被第二个参数替换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出11 22</span></span><br><span class="line">    <span class="built_in">bind</span>(func,std::placeholders::_1,std::placeholders::_2)(<span class="number">11</span>,<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(func,<span class="number">11</span>,_1)(<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>); <span class="comment">//输出 11 22 后面的33 44 没有作用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(func,_2,_1)(<span class="number">11</span>,<span class="number">22</span>); <span class="comment">//输出 22 11</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>####std::bind 和 std::function 的结合使用</p>
<p>std::function vs 函数指针</p>
<p>c++函数指针相信大家用的很多了，用法最高法的应该就是先定义函数指针的类型，然后在声明一个函数指针的变量作为另一个函数的入参，以此作为回调函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span> (<span class="type">int</span>)&gt; PrintFinCallback;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text,PrintFinCallback callback)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,text);</span><br><span class="line">    <span class="keyword">if</span>(callback)</span><br><span class="line">        <span class="built_in">callback</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printFinCallback</span><span class="params">(<span class="type">int</span> res)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Class Inter callback&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printFinCallback2</span><span class="params">(<span class="type">int</span> res1,<span class="type">int</span> res2)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Different callback&quot;</span> &lt;&lt; res1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; res2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test testobj;</span><br><span class="line">    <span class="comment">//std::function里定义的函数，只有一个参数，这里需要补充this参数</span></span><br><span class="line">    <span class="comment">//然后复用类成员函数类的第一个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> callback5 = std::<span class="built_in">bind</span>(&amp;Test::printFinCallback,testobj,std::placeholders::_1);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test 5&quot;</span>,callback5);</span><br><span class="line">    <span class="comment">//这里需要补充this参数 复用第一个参数 然后补充第二个参数</span></span><br><span class="line">    <span class="keyword">auto</span> callback6 = std::<span class="built_in">bind</span>(&amp;Test::printFinCallback2,testobj,std::placeholders::_1,<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test 6&quot;</span>,callback6);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 所以从本质上看  std::bind转化了函数签名，把类成员函数 从</span></span><br><span class="line"><span class="comment">// Test::printFinCallbackInter 需要两个参数，经过bind后变成需要一个参数</span></span><br><span class="line"><span class="comment">// &amp;Test::printFinCallback2 需要三个参数，经过bind后变成需要一个参数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p><strong>1.我们知道直接绑定这个类成员函数，就会报错，如果不用bind绑定，给它补充this参数，但是绑定仿函数却可以，这里一定有人会有疑问，本身仿函数，也是有this指针的，为啥成员函数不行，仿函数就可以呢？</strong></p>
<p>我们看下面这个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span> ()&gt; PrintFinCallback;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text,PrintFinCallback callback)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,text);</span><br><span class="line">    <span class="keyword">if</span>(callback)</span><br><span class="line">        <span class="built_in">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printFinCallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Static Class Inter callback&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFinCallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Normal callback&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Functor</span>&#123;</span><br><span class="line">    <span class="built_in">Functor</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Functor construct enter&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Functor callback&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test 3&quot;</span>,<span class="built_in">Functor</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个例子我们可以发现，调用仿函数的时候，会生成一个临时的对象，然后调用了构造函数，然后这个时候这个对象的this指针就传给了这个仿函数，也就是说它已经补充了this指针，所以不会报错</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><h4 id="lambda基础使用"><a href="#lambda基础使用" class="headerlink" title="lambda基础使用"></a>lambda基础使用</h4><p>lambda表达式是一个匿名函数，C++11中lambda表达式用于定义并创建匿名的函数对象，以简化编程工作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> f1 = [=]&#123;cout &lt;&lt; i &lt;&lt; endl;&#125;;</span><br><span class="line">        <span class="comment">//只捕获类成员变量，全局变量</span></span><br><span class="line">        <span class="keyword">auto</span> f2 = [<span class="keyword">this</span>]()&#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; temp &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> f1 = []()&#123;&#125;;</span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    <span class="keyword">auto</span> f2= [a,b]()&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">    <span class="keyword">auto</span> f3 = [a,b](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//以值传递方式传给lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> f4 = [=]&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="built_in">f4</span>();</span><br><span class="line">    <span class="comment">//以引用方式捕获外部变量</span></span><br><span class="line">    <span class="keyword">auto</span> f5 = [&amp;]&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="built_in">f5</span>();</span><br><span class="line">    <span class="comment">//a以值传递，其他以引用方式</span></span><br><span class="line">    <span class="keyword">auto</span> f6 = [&amp;,a]&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="comment">//默认情况下lambda表达式函数，以const修饰函数体，要想修改需要mutable 注意是能修改拷贝，而不是值本身</span></span><br><span class="line">    <span class="keyword">auto</span> f8 = [=]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; temp &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f8</span>();</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(<span class="built_in">f1</span>()).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  以引用和以值捕获的区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">auto</span> f1 = [&amp;]()<span class="keyword">mutable</span> &#123;</span><br><span class="line">    a++;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f1</span>();</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> f2 = [=]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    b++;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f2</span>();</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="lambda表达式与仿函数"><a href="#lambda表达式与仿函数" class="headerlink" title="lambda表达式与仿函数"></a>lambda表达式与仿函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunctor</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyFunctor</span>(<span class="type">int</span> i):<span class="built_in">r</span>(i)&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">10</span>;</span><br><span class="line">    <span class="function">MyFunctor <span class="title">obj</span><span class="params">(temp)</span></span>;</span><br><span class="line">    <span class="comment">//lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> f = [temp](<span class="type">int</span> t)&#123;</span><br><span class="line">        <span class="keyword">return</span> temp + t;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的例子我们可以看到，仿函数以r初始化类，而lambda函数也捕获了r变量，其它的，如果在参数传递上，两者保持一致。</p>
<p>除去在语法层面上的不同，lambda和仿函数有着相同的内涵-都可以捕获一些变量作为初始化状态，并接受参数进行运行。</p>
<p>而事实上，仿函数是编译器实现lambda的一种方式，通过编译器都是lambda表达式转化为一个仿函数对象。因此，在C++11中，lambda可以视为仿函数的一种等价形式。</p>
<h4 id="lambda类型"><a href="#lambda类型" class="headerlink" title="lambda类型"></a>lambda类型</h4><p>lambda表达式的类型在C++11中被称为“闭包类型”，每一个lambda表达式则会产生一个临时对象（右值）。</p>
<p>##Constexpr</p>
<h3 id="constexpr初识"><a href="#constexpr初识" class="headerlink" title="constexpr初识"></a>constexpr初识</h3><p>consexpr 是现代c++的一个重要且神奇的关键字。有了它，我们就可以编写在编译器就能执行的代码，从而提升运行时的性能</p>
<p>下面看个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">long</span> <span class="title">fibonacci</span><span class="params">(<span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">2</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fibConstExpr</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> n = <span class="built_in">fibonacci</span>(<span class="number">16</span>);</span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(fibConstExpr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fibNotConstExpr</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">    <span class="keyword">auto</span> n = <span class="built_in">fibonacci</span>(<span class="number">16</span>);</span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(fibNotConstExpr);</span><br></pre></td></tr></table></figure>

<p>![Screen Shot 2022-10-21 at 3.06.48 PM](/Users/valerian/Library/Application Support/typora-user-images/Screen Shot 2022-10-21 at 3.06.48 PM.png)</p>
<p>运行速度对比：<code>constexpr</code> 版本的<strong>耗时几乎为 0</strong>。</p>
<p>我们再来看看汇编的结果：</p>
<p>constexpr：</p>
<p>![Screen Shot 2022-10-21 at 3.09.23 PM](/Users/valerian/Desktop/Screen Shot 2022-10-21 at 3.09.23 PM.png)</p>
<p>notconstexpr：</p>
<p>![Screen Shot 2022-10-21 at 3.10.25 PM](/Users/valerian/Desktop/Screen Shot 2022-10-21 at 3.10.25 PM.png)</p>
<p>根据上面的汇编结果可以看出，<code>constexpr</code> 版本<strong>在编译之后已经得到最终结果了</strong>，不用在程序运行时进行递归计算。</p>
<p>上面的例子中，有两个地方用到的了constexpr关键字：</p>
<ol>
<li>修饰函数：constexpr long fibonacci(long n) 说明函数fibonacii是一个可以在编译期完成计算的函数（可以不代表一定）<ol>
<li>当函数参数可以在编译期确定时，则可以在编译期计算该函数的结果</li>
<li>当函数参数无法在编译期确定时，则该函数就是一个普通函数</li>
</ol>
</li>
<li>修饰对象：constexpr long a = fibonacci(16)  这里有两层含义：<ol>
<li>对象a是不可以改变的 （const）</li>
<li>对象a的值需要在编译期确定</li>
</ol>
</li>
</ol>
<h3 id="if-constexpr"><a href="#if-constexpr" class="headerlink" title="if constexpr"></a>if constexpr</h3><p>c++可以通过if constexpr实现条件编译的功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">long</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">long</span> <span class="title">fibonacci</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(N &gt;= <span class="number">2</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>&lt;N<span class="number">-1</span>&gt;() + <span class="built_in">fibonacci</span>&lt;N<span class="number">-2</span>&gt;();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">fibonacci</span>&lt;<span class="number">0</span>&gt;() == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">fibonacci</span>&lt;<span class="number">1</span>&gt;() == <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">fibonacci</span>&lt;<span class="number">2</span>&gt;() == <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">fibonacci</span>&lt;<span class="number">3</span>&gt;() == <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="constexpr-virtual-函数"><a href="#constexpr-virtual-函数" class="headerlink" title="constexpr virtual 函数"></a>constexpr virtual 函数</h3><p> constexpr 和 virtual 两个差不多截然相反的关键字</p>
<ul>
<li><code>virtual</code> 的含义是<strong>运行时</strong>多态。</li>
<li><code>constexpr</code> 则是<strong>编译期</strong>计算。</li>
</ul>
<p>那么，这两个关键字能一起修饰一个成员函数吗？答案是c++20版本开始是允许的。</p>
<p>###Constexpr 是如何在编译器执行的？</p>
<p>我们先介绍几个重要的数据结构</p>
<p><code>tree</code>是gcc内部的语法树。</p>
<p><code>constexpr_call</code>是gcc内部对constexpr函数的包装，它将函数定义、函数参数以及函数结果打包在一起，以便进行编译期求值。可将其和标准库的<code>std::function</code>类比一下，具体结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">constexpr_call</span> &#123;</span><br><span class="line">  <span class="comment">/* constexpr函数定义  */</span></span><br><span class="line">  constexpr_fundef *fundef;</span><br><span class="line">  <span class="comment">/* 打包的constexpr函数参数  */</span></span><br><span class="line">  tree bindings;</span><br><span class="line">  <span class="comment">/* 函数调用结果</span></span><br><span class="line"><span class="comment">    1. NULL表示constexpr函数正在被求值</span></span><br><span class="line"><span class="comment">    2. error_mark_node表示求值出现错误</span></span><br><span class="line"><span class="comment">    3. 其他值则表示正确的调用结果 */</span></span><br><span class="line">  tree result;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>constexpr_global_ctx</code>是全局constexpr上下文，每个cxx_eval_outermost_constant_expr()，即最外层的constexpr调用都需要有一个全局constexpr上下文，保存着表达式内部变量到到初始化值的映射，具体结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">constexpr_global_ctx</span> &#123;</span><br><span class="line">  <span class="comment">/* 保存常量表达式内部的局部变量或临时变量 */</span>  </span><br><span class="line">  hash_map&lt;tree,tree&gt; values;</span><br><span class="line">  <span class="comment">/* 在计算最外层常量表达式时创建的堆 */</span></span><br><span class="line">  auto_vec&lt;tree, <span class="number">16</span>&gt; heap_vars;</span><br><span class="line">  <span class="comment">/* 待释放的堆数量 */</span>  </span><br><span class="line">  <span class="type">unsigned</span> heap_dealloc_count;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">constexpr_ctx是<span class="keyword">constexpr</span>上下文，具体结构如下</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">constexpr_ctx</span> &#123;</span><br><span class="line">  <span class="comment">/* 当前的全局constexpr上下文  */</span></span><br><span class="line">  constexpr_global_ctx *global;</span><br><span class="line">  <span class="comment">/* 正在求值的constexpr函数  */</span></span><br><span class="line">  constexpr_call *call;</span><br><span class="line">  <span class="comment">/* 保存当前循环的表达式，如果没有在循环中则为 NULL */</span>  </span><br><span class="line">  vec&lt;tree&gt; *save_exprs;</span><br><span class="line">  <span class="comment">/* 当前constexpr对象的构造函数  */</span></span><br><span class="line">  tree ctor;</span><br><span class="line">  <span class="comment">/* 正在构造的constexpr对象.  */</span></span><br><span class="line">  tree object;</span><br><span class="line">  ...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="Concept概念"><a href="#Concept概念" class="headerlink" title="Concept概念"></a>Concept概念</h2><h3 id="为何要引入Concept"><a href="#为何要引入Concept" class="headerlink" title="为何要引入Concept"></a>为何要引入Concept</h3><p>我们在进行模版元编程的时候，经常会遇到一个问题：如何处理意料之外的类型</p>
<p>举例来说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEqual</span><span class="params">(T left,T right)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> left == right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>T</code>实例化为<code>int</code>、<code>double</code>、<code>char</code>甚至<code>std::string</code>都不会有什么问题，但是如果遇到字符串常量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEqual</span>(<span class="string">&quot;abc&quot;</span>, str)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里的意义就有可能发生改变，我们知道在C++中，字符串常量会作为const char *类型出现的，而如果这里的str也恰好是C风格的字符串的话，那么这里就会成为「比较指针」是否相等，而不是「比较值」。</p>
<p>所以，这时我们就需要对模板进行限定，并不要所有的类型都可以用于实例化IsEqual，而是必须“符合某些条件”才可以。</p>
<p>因此，Concept要解决的问题，就是对模板的实例化进行限定，只有满足条件的类型才可以进行实例化，否则编译器将会拦截。</p>
<h3 id="什么是Concept？"><a href="#什么是Concept？" class="headerlink" title="什么是Concept？"></a>什么是Concept？</h3><p>这里的concept最直白的解释就是「一个静态的bool类型」，如果它为<code>true</code>，那么表示模板可以实例化，如果为<code>false</code>则表示不允许实例化。</p>
<p>Concept语句需要书写在模板参数之后，模板实体之前，并且需要跟在<code>requires</code>关键字之后。我们举个最简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test1</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> <span class="literal">false</span></span><br><span class="line">strcut Test2&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上例中，Test1后跟了一个Concept语句，并且恒为true，那么表示，对于任何情况下，Test1都是允许实例化的，比如Test&lt; int &gt;、Test&lt; void* &gt;、Test&lt; std::string &gt;甚至Test&lt; void &gt;都是合法的实例。自然，这种恒true的情况下就可以省略Concpet，也就是说它和下面是等价的： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test1</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>而对于<code>Test2</code>来说，它的Concept语句是恒<code>false</code>，也就是说任何情况下都不允许实例化。</p>
<p>当然了，直接这样写肯定是没意义的，我们需要让这个Concept成为一些用于判断的语句，它才有价值。例如对于一个模板类，当<code>T</code>的大小小于等于<code>8</code>时才可以实例化，那么就可以写作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">requires</span> (<span class="built_in">sizeof</span>(T) &lt;= <span class="number">8</span>)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出，Concept基本就是在代替C++20之前的std::enable_if，解决的问题相同，但实现的思路却不同。std::enable_if利用的是SFINAE原则，按照更合适的模板匹配并进行实例化，把允许的「特例」进行实现，而「通用模板」则不实现，那么就可以似的通过SFINAE匹配到的类型可以正常编译，而其他类型则由于找不到通用的实现而无法通过编译（找不到type）。我们用C++17的标准改写上面的实例就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;<span class="built_in">sizeof</span>(T) &lt;= <span class="number">8</span>,<span class="type">void</span>&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Test &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>而当实例化的<code>T</code>不满足（例如用<code>std::string</code>实例化）时，会报错，因为找不到<code>std::enable_if&lt;false, void&gt;::type</code>。</p>
<p>Concept则是通过语言本身来解决这个问题的，自然会更加清晰直观。<strong>它其实就是在模板定义之前，单独搞了一个专门的区域，用于定义模板可实例化的条件</strong>，这样就不会出现满屏乱飞的<code>std::enable_if</code>和及其难以理解的模板嵌套。</p>
<h3 id="使用STL工具来做Concept"><a href="#使用STL工具来做Concept" class="headerlink" title="使用STL工具来做Concept"></a>使用STL工具来做Concept</h3><p>既然Concept就是一个静态布尔值，那么STL当中的一些返回静态布尔类型的工具就天然可以作为Concept了，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* is_trivial_v 是一个编译器能算出来的bool值 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> std::is_trivial_v&lt;T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test1</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> std::is_base_of_v&lt;google::protobuf::Message,T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test2</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>那复合Concept怎么办？比如说要求平凡 且 长度小于指针 那么同样，可以利用工具</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> std::conjunction_v&lt;std::is_trivial&lt;T&gt;,std::bool_constant&lt;<span class="built_in">sizeof</span>(T) &lt;= <span class="built_in">sizeof</span>(<span class="type">void</span> *)&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Test&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Concept块"><a href="#Concept块" class="headerlink" title="Concept块"></a>Concept块</h3><p>我们看看如何用块的形式表示上一节当中conjunction的表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> <span class="keyword">requires</span> &#123;</span><br><span class="line">  std::is_trivial_v&lt;T&gt;;</span><br><span class="line">  <span class="built_in">sizeof</span>(T) &lt;= <span class="built_in">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">&#125; || std::is_trivially_copyable_v&lt;T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里出现了两个requires大家不要惊讶，前面章节我说过，concept书写的位置在模板参数之后，模板实体之前，并且要有requires标记。所以这里的第一个requires就是语法结构上的这个标记，用于表明，后面要跟一个concept。</p>
<p>而第二个requires则是用于定义一个concept中需要满足的条件列表，也就是说，它是用来修饰后面的大括号的，表示这个大括号里应当是concept块，而不是普通的代码块。</p>
<p>在concept块中可以定义一组静态布尔语句，之间用分号隔开，它们之间是“逻辑与”的关系，也就是说所有的条件都需要满足，才认为这个concept是满足的。</p>
<p>需要注意的是，一个concept块本质就是一个静态布尔表达式，所以多个concept之间是可以用逻辑符来拼接的，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> <span class="keyword">requires</span> &#123;</span><br><span class="line">  std::is_trivial_v&lt;T&gt;;</span><br><span class="line">  <span class="built_in">sizeof</span>(T) &lt;= <span class="built_in">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">&#125; || std::is_trivially_copyable_v&lt;T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>当然concept也可以替换成concept块：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> <span class="keyword">requires</span> &#123;</span><br><span class="line">  std::is_trivial_v&lt;T&gt;;</span><br><span class="line">  <span class="built_in">sizeof</span>(T) &lt;= <span class="built_in">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">&#125; || <span class="keyword">requires</span> &#123;</span><br><span class="line">  std::is_trivially_copyable_v&lt;T&gt;;</span><br><span class="line">  <span class="built_in">sizeof</span>(T) &lt;= <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="独立定义Concept"><a href="#独立定义Concept" class="headerlink" title="独立定义Concept"></a>独立定义Concept</h3><p>如果每次我们都直接在模板里定义concept会有两个潜在的问题：一是有可能会由于concept过长而导致模板定义过长；二是如果多个模板需要使用同样的concept则无法复用。</p>
<p>因此，C++也提供了独立定义concept的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> Available = <span class="keyword">requires</span> &#123;</span><br><span class="line">  std::is_trivial_v&lt;T&gt;;</span><br><span class="line">  <span class="built_in">sizeof</span>(T) &lt;= <span class="built_in">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于，concept不再仅仅是一种概念，还成为了C++20中的新关键字。用<code>concept</code>关键字可以定义一个独立的concept，独立定义的concept可以直接出现在模板的concept语句中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> Available&lt;T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，与C++17中直接定义静态bool类型不同，concept本身就是一个静态布尔类型了，所以不需要取<code>value</code>。如果用C++17的方式定义上面的则应该是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Available</span> : std::conjunction_v&lt;</span><br><span class="line">				     std::is_trivial&lt;T&gt;, </span><br><span class="line">					 std::bool_constant&lt;<span class="built_in">sizeof</span>(T) &lt;= <span class="built_in">sizeof</span>(<span class="type">void</span> *)&gt;</span><br><span class="line">					&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">inline</span> <span class="type">bool</span> Available_v = Available&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>

<p>因此在concept中，我们再也不用考虑所谓“traits类型本身”“traits结果类型”“traits静态value”这些乱七八糟的概念，也不用考虑什么时候该加<code>_t</code>，什么时候该加<code>_v</code>。</p>
<h3 id="更加强大的concept"><a href="#更加强大的concept" class="headerlink" title="更加强大的concept"></a>更加强大的concept</h3><p>前面我们介绍的是一些concept的简单用法，但其实concept远不止如此，它还可以更优雅地解决很多复杂的需求。</p>
<ol>
<li>判断某个成员是否存在</li>
</ol>
<p>例如，我们要求类型T需要实现desc方法，如果用c++17的方法是这样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(T::desc)&gt;&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>思路就是用SFINAE匹配，如果T::desc存在，那么会被std::void_t转化为void，并成功命中下面的偏特化。而如果T::desc不存在，则会命中上面的通用模板，又因为通用模板是未定义的，因此不能通过编译。但显然，写出这样的代码需要很高的门槛，必须对模板元编程烂熟于心，并熟练掌握SFINAE的匹配原则，然后给编译期玩出这样的文字游戏。<br>但有了concept，一切都变得简单了，现在我们可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> <span class="keyword">requires</span> &#123;</span><br><span class="line">  T::desc; <span class="comment">// 表示T::desc是合理语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在concept语句中，可以单纯写一个表达式，用于表示「可以执行这样的表达式」，用上面的例子来说就是，对于一个类型<code>T</code>，如果我能取到<code>T::desc</code>，那么就认为它符合要求。</p>
<p>然而这样带来了另一个问题就是，我不能确定<code>T::desc</code>到底是个什么，如果是个成员变量那也能通过：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> <span class="keyword">requires</span> &#123;</span><br><span class="line">  T::desc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> desc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">desc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test&lt;T1&gt; t1; <span class="comment">// OK</span></span><br><span class="line">  Test&lt;T2&gt; t2; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况我们可以用std::is_function来解决：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> <span class="keyword">requires</span> &#123;</span><br><span class="line">  std::is_function_v&lt;<span class="keyword">decltype</span>(T::desc)&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>判断非静态成员变量</li>
</ol>
<p>刚才的例程仅仅对静态成员生效，但如果我要求<code>desc</code>是非静态成员函数呢？用C++17的方法是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Available : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Available</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(&amp;T::desc)&gt;&gt; :</span><br><span class="line">  std::is_member_function_pointer&lt;<span class="keyword">decltype</span>(&amp;T::desc)&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;Available&lt;T&gt;::value&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Test &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>而如果用concept，则会是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> <span class="title">requires</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">  t.<span class="built_in">desc</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>隆重介绍concept语句的「参数列表」。在concept的requires后可以跟一个列表，来定义一些用于静态判断的“变量”，注意这里的变量是没有实际意义的，它也不会在实际执行时被初始化，它仅仅是用于承担“静态语法判断”的工作。</p>
<p>那么上面的例子可以解释为“对于一个T类型的变量，如果它可以执行t.desc()这样的语句，那么就视为合法”，那么我们也就达成了“判断T是否含有一个非动态成员函数desc”的目的。</p>
<ol start="3">
<li>判断某个语句的返回值</li>
</ol>
<p>那如果我要求desc是个非静态成员函数，并且返回值是void，参数为空，那怎么办？如果用c++17的方法，就要开始炫技了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Available : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Available</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(&amp;T::desc)&gt;&gt; :</span><br><span class="line">std::disjunction&lt;</span><br><span class="line">  std::is_same&lt;<span class="keyword">decltype</span>(&amp;T::desc), <span class="built_in">void</span> (T::*)(<span class="type">void</span>)&gt;,</span><br><span class="line">  std::is_same&lt;<span class="keyword">decltype</span>(&amp;T::desc), <span class="built_in">void</span> (T::*)(<span class="type">void</span>) <span class="type">const</span>&gt;,</span><br><span class="line">  std::is_same&lt;<span class="keyword">decltype</span>(&amp;T::desc), <span class="built_in">void</span> (T::*)(<span class="type">void</span>) <span class="keyword">noexcept</span>&gt;,</span><br><span class="line">  std::is_same&lt;<span class="keyword">decltype</span>(&amp;T::desc), <span class="built_in">void</span> (T::*)(<span class="type">void</span>) <span class="type">const</span> <span class="keyword">noexcept</span>&gt;</span><br><span class="line">&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;Available&lt;T&gt;::value&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Test &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">desc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">desc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T3</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> desc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test&lt;T1&gt; t1; <span class="comment">// OK</span></span><br><span class="line">  Test&lt;T2&gt; t2; <span class="comment">// ERR</span></span><br><span class="line">  Test&lt;T3&gt; t3; <span class="comment">// ERR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看利用concept优雅地解决这个问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> <span class="title">requires</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">  t.<span class="built_in">desc</span>();</span><br><span class="line">  std::is_same_v&lt;<span class="keyword">decltype</span>(t.<span class="built_in">desc</span>()), <span class="type">void</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这还不够优雅，concept提供了用于语句返回值判断的语法，那么上面的代码可以改写成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> <span class="title">requires</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">  &#123;t.<span class="built_in">desc</span>()&#125;-&gt;std::same_as&lt;<span class="type">void</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>用一个大括号括起来的语句，表示取这个语句的返回值，当然，它的前提是这个语句能正常执行。那么，后面这个<code>std::same_as</code>又是何方神圣呢？</p>
<p>这是STL提供的一些concept之一，它的定义是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">concept</span> same_as = std::is_same_v&lt;T1, T2&gt;;</span><br></pre></td></tr></table></figure>

<p>就是把std::is_same_v定义成了concept，但这却让它发挥了神奇的功效。在使用大括号表示语句返回值后，返回值类型会传递给后面concept的第一个参数，也就是说        { t.desc( ) }-&gt;std::same_as&lt; void &gt;是把t.desc( )语句的返回值传给了std::same_as的T1，而尖括号里的void则是传给了T2。</p>
<p>所以对于一个concept：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C1 = <span class="built_in">requires</span>(T t) &#123;</span><br><span class="line">  &#123;t.<span class="built_in">desc</span>()&#125;-&gt;std::same_as&lt;<span class="type">void</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>就等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C2 = <span class="built_in">requires</span>(T t) &#123;</span><br><span class="line">  std::is_same_v&lt;<span class="keyword">decltype</span>(t.<span class="built_in">desc</span>()), <span class="type">void</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这下，concept的写法确实对得起“优雅”一词了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>concept是enable_if的替代方案，用于约束模板是否允许实例化；</li>
<li>concept本质是一个静态布尔类型表达式，可以直接用布尔常量、或是静态布尔类型变量来代替；</li>
<li>C++17中的一些_v结尾的工具通常可以直接作为concept使用；</li>
<li>concept可以用concept关键字来独立定义；</li>
<li>在concept块中，表达式均表示“能够这样执行”的含义，并且表达式之间是逻辑与的关系；</li>
<li>concept块可以有参数列表，来定义“语法解析”层面的“变量”；</li>
<li>concept块中可以用大括号返回表达式的返回值，并把返回值类型交给-&gt;后的concept的第一个模板参数。</li>
</ul>
<h2 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h2><p>Substitution Failure is Not An Error</p>
<p>什么事substitution </p>
<p>所谓substitution，就是将函数模版中的形参，替换成实参的过程。我们来看一个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T0,<span class="comment">/* 其他模版参数 */</span><span class="keyword">typename</span> U = &gt;</span><br><span class="line">RType <span class="built_in">functionName</span>(PType0,PType1)&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>下面有一个更具体的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U = <span class="keyword">typename</span> vector&lt;T&gt;::iteartor &gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;T&gt;::value_type</span><br><span class="line">  <span class="built_in">foo</span>(</span><br><span class="line">  	T*,</span><br><span class="line">		T&amp;;</span><br><span class="line">    <span class="keyword">typename</span> T::internal_type,</span><br><span class="line">	  <span class="type">int</span></span><br><span class="line">)&#123;</span><br><span class="line">  <span class="comment">//整个实现部分，都没有substitution </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">int</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">int</span> type2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">typename</span> T::type)</span></span>; <span class="comment">// Foo0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">typename</span> T::type2)</span></span>;  <span class="comment">// Foo1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T)</span></span>; <span class="comment">// Foo2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>&lt;X&gt;(<span class="number">5</span>); <span class="comment">// Foo0: Succeed, Foo1: Failed,  Foo2: Failed</span></span><br><span class="line">  <span class="built_in">foo</span>&lt;Y&gt;(<span class="number">10</span>);  <span class="comment">// Foo0: Failed,  Foo1: Succeed, Foo2: Failed</span></span><br><span class="line">  <span class="built_in">foo</span>&lt;<span class="type">int</span>&gt;(<span class="number">15</span>); <span class="comment">// Foo0: Failed,  Foo1: Failed,  Foo2: Succeed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="C-并发与多线程"><a href="#C-并发与多线程" class="headerlink" title="C++并发与多线程"></a>C++并发与多线程</h1><h2 id="第一节：并发"><a href="#第一节：并发" class="headerlink" title="第一节：并发"></a>第一节：并发</h2><h3 id="并发的基本概念"><a href="#并发的基本概念" class="headerlink" title="并发的基本概念"></a>并发的基本概念</h3><ul>
<li><p>两个或者更多的任务（独立活动）同时发生（进行）：一个程序同时执行多个独立任务；</p>
</li>
<li><p>以往计算机，单核CPU：某一个时刻只能执行一个任务：由操作系统调度，每秒钟进行多次所谓的“任务切换”并发的假象：这种上下文切换，是要有时间开销的，操作系统要保存你切换时的各种状态，执行进度等信息。</p>
</li>
<li><p>硬件发展，出现了多处理器计算机，用于服务器和高性能计算，能够实现真正的并行执行多个任务</p>
</li>
<li><p>使用并发的原因：同时执行多个任务，提高性能？</p>
</li>
</ul>
<h3 id="进程与可执行程序"><a href="#进程与可执行程序" class="headerlink" title="进程与可执行程序"></a>进程与可执行程序</h3><ul>
<li>磁盘上的一个文件 .exe</li>
<li>进程就是运行起来的可执行程序</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>每个进程，都有一个主线程，这个主线程是唯一的，也就是一个进程中只能有一个主线程。</li>
<li>当执行一个可执行程序，产生一个进程后，这个主线程就随着这个进程默默的启动起来了。线程就是一个代码的执行通路</li>
<li>运行这个程序的时候实际上是进程的主线程来执行（调用）这个main函数中的代码主线程与线程同生共死。</li>
<li>除了主线程之外，我们可以通过自己写代码创建其他线程，其他线程走的是别的道路，甚至去不同的地方。每创建一个新线程，就可以在同一时刻，多干一个不同的事情（走一条不同的代码执行路径）</li>
<li>多线程（并发）并不是越多越好，每一个线程都需要一个独立的堆栈空间，线程之间切换要保存很多中间状态，切换会耗费本该属于程序运行的时间。</li>
</ul>
<p>###并发的实现方法</p>
<p>实现并发的手段：</p>
<ol>
<li>我们可以通过多个进程实现并发</li>
<li>在单独的进程中创建多个线程来实现并发</li>
</ol>
<p>####多进程并发</p>
<p>进程间的通信：</p>
<ul>
<li>同一个电脑：管道、文件、消息队列、共享内存</li>
<li>不同电脑：socket通信技术。</li>
</ul>
<p>####多线程并发</p>
<p>当个进程中创建了多个线程，每个线程都有自己独立的运行路径，但是一个进程中的所有线程共享地址空间（共享内存）；全局变量、指针、引用都可以在在线程之间传递，所以多线程开销远远小于多进程，所以我们尽量使用多线程技术手段。</p>
<p>但共享内存带来新问题，数据一致性问题</p>
<h2 id="第二节线程启动、结束"><a href="#第二节线程启动、结束" class="headerlink" title="第二节线程启动、结束"></a>第二节线程启动、结束</h2><h4 id="线程运行的开始和结束"><a href="#线程运行的开始和结束" class="headerlink" title="线程运行的开始和结束"></a>线程运行的开始和结束</h4><p>程序运行起来 生成一个进程，该进程所属的主线程开始自动运行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TA</span>(<span class="type">int</span>&amp; i):<span class="built_in">m_i</span>(i)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造函数执行&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TA</span>(<span class="type">const</span> TA&amp; ta):<span class="built_in">m_i</span>(ta.m_i)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">TA</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我的线程operator()开始执行了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>&amp; m_i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line">    <span class="function">TA <span class="title">obj</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">mytobj2</span><span class="params">(obj)</span></span>;</span><br><span class="line">    mytobj2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">//mytobj2.detach();//一旦detach主线程结束了，局部变量obj对象会被释放，但是由于是复制到线程中去的，所以执行完主线程后，ta会被销毁</span></span><br><span class="line">   <span class="comment">// 只要TA类对象里面没有引用，没有指针，那么就不会造成问题</span></span><br><span class="line"><span class="comment">//    auto myLamthread = []&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; &quot;我的线程开始执行&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line"><span class="comment">//    thread mytobj4(myLamthread);</span></span><br><span class="line"><span class="comment">//    mytobj4.detach();</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;I love China&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//thread是个标准库里的类</span></span><br><span class="line">    <span class="comment">//thread mytobj(myPrint); //myprint是可调用对象 线程开始的起点是myPrint、</span></span><br><span class="line">    <span class="comment">// 阻塞主线程，让主线程等待子线程执行完毕，然后子线程和主线程汇合</span></span><br><span class="line"><span class="comment">//    if(mytobj.joinable())&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; 1;</span></span><br><span class="line"><span class="comment">//    &#125;else&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; 0;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//主线程阻塞到这里等待myprint()执行完，当子线程执行完毕，join执行完毕，主线程继续往后走</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    if(mytobj.joinable())&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; 1;</span></span><br><span class="line"><span class="comment">//    &#125;else&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; 0;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//detach 分离 主线程不和子线程汇合了，你主线程执行你的，子线程与主线程失去联系</span></span><br><span class="line">    <span class="comment">// ，此时这个子线程就会驻留在后台运行，这个子线程执行完成后，</span></span><br><span class="line">    <span class="comment">// 由运行时库负责清理该线程相关的资源（守护线程）</span></span><br><span class="line">    <span class="comment">//一旦detach之后就不能join了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//joinable 判断是否可以成功使用join或者detach的 返回true或者false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他可调用对象 可调用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="第三节"><a href="#第三节" class="headerlink" title="第三节"></a>第三节</h2><h1 id="C-设计模式"><a href="#C-设计模式" class="headerlink" title="C++设计模式"></a>C++设计模式</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>###工厂方式模式</p>
<ul>
<li>Creator.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CPP_CREATOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Product.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Movie&gt; <span class="title">get_movie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPP_CREATOR_H</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>ConcreteCreator.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPP_CONCRETECREATOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPP_CONCRETECREATOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConcreteProduct.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Creator.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChineseProducer</span> : <span class="keyword">public</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Movie&gt; <span class="title">get_movie</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ChineseMovie&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JapaneseProducer</span> : <span class="keyword">public</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Movie&gt; <span class="title">get_movie</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;JapaneseMovie&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AmericanProducer</span> : <span class="keyword">public</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Movie&gt; <span class="title">get_movie</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;AmericanMovie&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>ConcreteProduct.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPP_CONCRETEPRODUCT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPP_CONCRETEPRODUCT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Product.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChineseMovie</span> : <span class="keyword">public</span> Movie&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">get_a_movie</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;让子弹飞&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JapaneseMovie</span> : <span class="keyword">public</span> Movie&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">get_a_movie</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;《千与千寻》&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AmericanMovie</span> : <span class="keyword">public</span> Movie&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string  <span class="title">get_a_movie</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;《钢铁侠》&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPP_CONCRETEPRODUCT_H</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Product.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">get_a_movie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Main.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConcreteCreator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Factory&gt; factory;</span><br><span class="line">    std::shared_ptr&lt;Movie&gt; product;</span><br><span class="line"></span><br><span class="line">    std::string conf = <span class="string">&quot;China&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conf == <span class="string">&quot;China&quot;</span>) &#123;</span><br><span class="line">        factory = std::<span class="built_in">make_shared</span>&lt;ChineseProducer&gt;();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (conf == <span class="string">&quot;Japan&quot;</span>) &#123;</span><br><span class="line">        factory = std::<span class="built_in">make_shared</span>&lt;JapaneseProducer&gt;();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (conf == <span class="string">&quot;America&quot;</span>) &#123;</span><br><span class="line">        factory = std::<span class="built_in">make_shared</span>&lt;AmericanProducer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    product = factory-&gt;<span class="built_in">get_movie</span>();</span><br><span class="line">    std::cout &lt;&lt; product-&gt;<span class="built_in">get_a_movie</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###抽象工厂模式</p>
<ul>
<li>AbstractFactory.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPP_ABSTRACTFACTORY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPP_ABSTRACTFACTORY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AbstractProduct.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Movie&gt; <span class="title">productMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;Book&gt; <span class="title">productBook</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPP_ABSTRACTFACTORY_H</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>AbstractProduct.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">showMovieName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">showBookName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPP_ABSTRACTPRODUCT_H</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>ConcreteProduct.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPP_CONCRETEPRODUCT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPP_CONCRETEPRODUCT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AbstractProduct.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChineseMovie</span> : <span class="keyword">public</span> Movie&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">showMovieName</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;《让子弹飞》&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JapaneseMovie</span> : <span class="keyword">public</span> Movie&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">showMovieName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;《千与千寻》&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChineseBook</span> : <span class="keyword">public</span> Book&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">showBookName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;《三国演义》&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JapaneseBook</span> : <span class="keyword">public</span> Book&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">showBookName</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;《白夜行》&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPP_CONCRETEPRODUCT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>ConcreteFactory.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPP_CONCRETEFACTORY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPP_CONCRETEFACTORY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AbstractFactory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConcreteProduct.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChineseProducer</span> : <span class="keyword">public</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Movie&gt; <span class="title">productMovie</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ChineseMovie&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Book&gt; <span class="title">productBook</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ChineseBook&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JapaneseProducer</span> : <span class="keyword">public</span> Factory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Movie&gt; <span class="title">productMovie</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;JapaneseMovie&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Book&gt; <span class="title">productBook</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;JapaneseBook&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPP_CONCRETEFACTORY_H</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Main.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ConcreteFactory.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Factory&gt; factory;</span><br><span class="line">    factory = std::<span class="built_in">make_shared</span>&lt;ChineseProducer&gt;();</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;Movie&gt; movie;</span><br><span class="line">    std::shared_ptr&lt;Book&gt; book;</span><br><span class="line">    movie = factory-&gt;<span class="built_in">productMovie</span>();</span><br><span class="line">    book = factory-&gt;<span class="built_in">productBook</span>();</span><br><span class="line">    std::cout &lt;&lt; movie-&gt;<span class="built_in">showMovieName</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; book-&gt;<span class="built_in">showBookName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###生产器模式</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/25691068/1646451516140-21d9d2fb-b9c4-488c-a1e8-d67039a62a8b.png?x-oss-process=image/resize,w_1500,limit_0" alt="image.png"></p>
<ul>
<li><p>生成器（Builder）接口声明在所有类型生成器中通用的产品构造步骤。</p>
</li>
<li><p>具体生成器（Concrete Builders）提供构造过程的不同实现。具体生成器也可以构造不遵循通用接口的产品。</p>
</li>
<li><p>产品（Products）是最终生成的对象。由不同生成器构造的产品无需属于同一类层次结构或接口。</p>
</li>
<li><p>主管（Director）类定义调用构造步骤的顺序，这样你就可以创建和复用特定的产品配置。</p>
</li>
<li><p>客户端（Client）必须将某个生成器对象与主管类关联。一般情况下，你只需通过主管类构造函数的参数进行一次性关联即可。此后主管类就能使用生成器对象完成后续所有的构造任务。但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。在这种情况下，你在使用主管类生产产品时每次都可以使用不同的生成器。</p>
</li>
<li><p>Product.h</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPP_PRODUCT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPP_PRODUCT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Car</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_car_tire</span><span class="params">(std::string t)</span></span>&#123;</span><br><span class="line">        tire_ = t;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Set tire: &quot;</span> &lt;&lt; tire_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_car_steering_wheel</span><span class="params">(std::string sw)</span></span>&#123;</span><br><span class="line">        steering_wheel_ = sw;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;set steering wheel: &quot;</span> &lt;&lt; steering_wheel_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string tire_;</span><br><span class="line">    std::string steering_wheel_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPP_PRODUCT_H</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li>Builder.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildTire</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildSteeringWheel</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Car car_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li></li>
</ul>
<h3 id="原型模式（Prototype）"><a href="#原型模式（Prototype）" class="headerlink" title="原型模式（Prototype）"></a>原型模式（Prototype）</h3><p>定义：</p>
<p>原型是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类。</p>
<p>实例：</p>
<ul>
<li>Prototype.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Object* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>ConcretePrototype.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Prototype.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Attachment</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_content</span><span class="params">(std::string )</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>





<h1 id="C-内存分配"><a href="#C-内存分配" class="headerlink" title="C++内存分配"></a>C++内存分配</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_60596960/article/details/124747629">https://blog.csdn.net/weixin_60596960/article/details/124747629</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;mid=2247485953&amp;idx=1&amp;sn=f8cd484607ab07f15247ecde773d2e1c&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&amp;mid=2247485953&amp;idx=1&amp;sn=f8cd484607ab07f15247ecde773d2e1c&amp;scene=21#wechat_redirect</a></p>
<h2 id="类中的内存"><a href="#类中的内存" class="headerlink" title="类中的内存"></a>类中的内存</h2><h3 id="普通类对象的内存分配"><a href="#普通类对象的内存分配" class="headerlink" title="普通类对象的内存分配"></a>普通类对象的内存分配</h3><p>成员函数是不占用对象的内存空间的，只有成员变量会占用对象的内存空间。所以 sizeof(Name1) 只计算了两个成员变量的内存空间，在32位系统中，int型变量占用4字节，所以 sizeof(Name1) = 8（需要注意的是：如果类中没有定义这两个成员变量，则 sizeof(Name1) = 1，这是C++规定的）。在C++中类的成员成员成员函数是所有类对象所“共享的”</p>
<ul>
<li>成员函数的地址是和成员变量的地址是没有关系的，而且各成员函数的关系也没有一定的关联性。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">k</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a\t addr:0x%p\n&quot;</span>,&amp;a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m1,m2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Name1 obj;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;对象地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj \t addr: 0x%p\n&quot;</span>, &amp;obj);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n成员变量地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1 \t addr: 0x%p\n&quot;</span>, &amp;obj.m1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m2 \t addr: 0x%p\n&quot;</span>, &amp;obj.m2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n成员函数地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f() \t addr: 0x%p\n&quot;</span>, &amp;Name1::f); <span class="comment">//成员函数f一定要有函数体的定义，下同</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k() \t addr: 0x%p\n&quot;</span>, &amp;Name1::k);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nobj 中函数 k() 局部变量 a 的地址为 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    obj.<span class="built_in">k</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nobj2 中函数 k() 局部变量 a 的地址为 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Name1 obj2;</span><br><span class="line">    obj2.<span class="built_in">k</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，普通类对象的内存分配模型如下所示</p>
<p><img src="https://img-blog.csdnimg.cn/20210521162249468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWxhbmdfemhpenVu,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="含有虚函数的类对象的内存分配"><a href="#含有虚函数的类对象的内存分配" class="headerlink" title="含有虚函数的类对象的内存分配"></a>含有虚函数的类对象的内存分配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Name2::f&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Name2::g&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vh</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Name2::vh&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vk</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Name2::vk&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m1 , m2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Name2 obj;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(Name2) = %d\n&quot;</span>,<span class="built_in">sizeof</span>(Name2));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;对象地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj \t addr: 0x%p\n&quot;</span>, &amp;obj);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n成员变量地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1 \t addr: 0x%p\n&quot;</span>, &amp;obj.m1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m2 \t addr: 0x%p\n&quot;</span>, &amp;obj.m2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n成员函数地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f() \t addr: 0x%p\n&quot;</span>, &amp;Name2::f); <span class="comment">//成员函数f一定要有函数体的定义，下同</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g() \t addr: 0x%p\n&quot;</span>, &amp;Name2::g);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vh() \t addr: 0x%p\n&quot;</span>, &amp;Name2::vh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vk() \t addr: 0x%p\n&quot;</span>, &amp;Name2::vk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在我们已经证明了vptr指针的存在，那我们怎么能证明vptr指针指向了虚函数表呢？<strong>我们可以通过vptr指针获取虚函数表，然后取出虚函数表中存放的函数指针，通过函数指针进行函数调用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">play02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pFunc)</span><span class="params">()</span></span>;		<span class="comment">//定义 void func(); 类型的函数指针类型</span></span><br><span class="line">    Name2 obj;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n成员函数地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vh() \t addr: 0x%p\n&quot;</span>, &amp;Name2::vh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vk() \t addr: 0x%p\n&quot;</span>, &amp;Name2::vk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先获取obj的地址，也即内存首地址，首地址中存放的是指针（vptr），所以p 实际上就是指针的指针</span></span><br><span class="line">    <span class="type">void</span> **p = (<span class="type">void</span> **)&amp;obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*p取得的是vptr的值，vptr指向虚函数表，虚函数表中存放的是指针（函数指针），所以vptr实际上也是指针的指针</span></span><br><span class="line">    <span class="type">void</span> **vptr = (<span class="type">void</span> **)*p;		<span class="comment">//相当于 void *vptr[]; 表明是一个数组，数组中存放的是指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj vh: %p\n&quot;</span>, vptr[<span class="number">0</span>]);    <span class="comment">//第一个虚函数的函数指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj vk: %p\n&quot;</span>, vptr[<span class="number">1</span>]);    <span class="comment">//第二个虚函数的函数指针</span></span><br><span class="line"></span><br><span class="line">    pFunc ph = (pFunc)vptr[<span class="number">0</span>];</span><br><span class="line">    pFunc pk = (pFunc)vptr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n函数指针调用结果：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">ph</span>();</span><br><span class="line">    <span class="built_in">pk</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">还有一种方式maybe能获取到虚函数表中的虚函数地址</span><br><span class="line">  </span><br><span class="line">pFunc ph = (pFunc)*((<span class="type">int</span>*)*(<span class="type">int</span>*)&amp;obj+<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）、先通过 &amp;obj 取得对象的地址（也即指向vptr指针的指针），通过(<span class="type">int</span> *)转换成可操作的指针【(<span class="type">int</span> *)&amp;obj】；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）、然后通过 * 解引用取得 vptr 指针的值，也即指向虚函数表的指针，也即虚函数表的首地址（类似于数组，<span class="type">int</span> arr[<span class="number">10</span>]; arr即使数组名，又表示数组指针，又表示数组的首地址，同时arr又能当做指针来用），通过 (<span class="type">int</span> *) 转换成可操作的指针【(<span class="type">int</span>*)*(<span class="type">int</span>*)&amp;obj】；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）、取得虚函数表的首地址之后（实际上就是数组的首地址），就可以通过加减操作取得数组成员了，+<span class="number">0</span>获得第<span class="number">0</span>个元素的指针，+<span class="number">1</span>获得第<span class="number">1</span>个元素的指针【(<span class="type">int</span>*)*(<span class="type">int</span>*)&amp;obj + <span class="number">0</span>】；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）、再然后通过 * 解引用就可获得数组中的元素了（函数指针）【*((<span class="type">int</span>*)*(<span class="type">int</span>*)&amp;obj + <span class="number">0</span>)】；然后通过强制转换将指针转换成函数指针类型【(pFunc)*((<span class="type">int</span>*)*(<span class="type">int</span>*)&amp;obj + <span class="number">0</span>)】;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里注意一下 在clion中通过 *(<span class="type">int</span>*)*(<span class="type">int</span>*)(&amp;b) 依旧取不到虚函数表地址</span><br></pre></td></tr></table></figure>

<p>值得注意的是 打印的成员函数的地址和下面打印的虚函数表中存放的虚函数函数指针是不一致的，具体原因如下：</p>
<p>有些书上说是获取到虚函数在虚函数表中的索引。但是实际上VS编译器并不是这么做的，获取到的将会是一个用于虚函数调用的地址，这个地址上的指令会先获取虚函数表，然后再通过虚函数表获取虚函数地址相关的项。而GCC的做法又跟VS不同，通过&amp;获取得的值都是1。总而言之，通过取地址&amp;符号获得的不是函数地址，但是可以通过获得的值成功调用该函数。</p>
<p>所以，含有虚函数的类对象的内存分配模型如下所示</p>
<p><img src="https://img-blog.csdnimg.cn/2021052411384027.png" alt="img"></p>
<p>###普通派生类的内存分配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base_m1,base_m2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;Derived::f1&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;Derived::g1&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derived_m1 , derived_m2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(Derived) = %d\n&quot;</span>,<span class="built_in">sizeof</span>(Derived));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;对象地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj \t addr: 0x%p\n&quot;</span>, &amp;obj);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n成员变量地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;base_m1 \t addr: 0x%p\n&quot;</span>, &amp;obj.base_m1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;base_m2 \t addr: 0x%p\n&quot;</span>, &amp;obj.base_m2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;derived_m1 \t addr: 0x%p\n&quot;</span>, &amp;obj.derived_m1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;derived_m2 \t addr: 0x%p\n&quot;</span>, &amp;obj.derived_m2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n成员函数地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f() \t addr: 0x%p\n&quot;</span>, &amp;Derived::f); <span class="comment">//成员函数f一定要有函数体的定义，下同</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g() \t addr: 0x%p\n&quot;</span>, &amp;Derived::g);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vh() \t addr: 0x%p\n&quot;</span>, &amp;Derived::f1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vk() \t addr: 0x%p\n&quot;</span>, &amp;Derived::g1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，普通派生类的内存分配模型如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210524134952397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWxhbmdfemhpenVu,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="含有虚函数的派生类的内存分配"><a href="#含有虚函数的派生类的内存分配" class="headerlink" title="含有虚函数的派生类的内存分配"></a>含有虚函数的派生类的内存分配</h3><h4 id="派生类没有重写基类的虚函数"><a href="#派生类没有重写基类的虚函数" class="headerlink" title="派生类没有重写基类的虚函数"></a>派生类没有重写基类的虚函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Base::f&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Base::g&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base_m1,base_m2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Derived::f1&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Derived::g1&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derived_m1 , derived_m2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    Derived obj;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(Base) = %d\n&quot;</span>,<span class="built_in">sizeof</span>(Base));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(Derived) = %d\n&quot;</span>,<span class="built_in">sizeof</span>(Derived));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;对象地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;derived_obj \t addr: 0x%p\n&quot;</span>, &amp;obj);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n成员变量地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;base_m1 \t addr: 0x%p\n&quot;</span>, &amp;obj.base_m1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;base_m2 \t addr: 0x%p\n&quot;</span>, &amp;obj.base_m2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;derived_m1 \t addr: 0x%p\n&quot;</span>, &amp;obj.derived_m1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;derived_m2 \t addr: 0x%p\n&quot;</span>, &amp;obj.derived_m2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n成员函数地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f() \t addr: 0x%p\n&quot;</span>, &amp;Derived::f); <span class="comment">//成员函数f一定要有函数体的定义，下同</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g() \t addr: 0x%p\n&quot;</span>, &amp;Derived::g);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vh() \t addr: 0x%p\n&quot;</span>, &amp;Derived::f1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vk() \t addr: 0x%p\n&quot;</span>, &amp;Derived::g1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在64位计算机上面 基类的大小为16，但是在派生类中大小为24，说明虽然派生类类继承自基类，但并没有继承基类的vptr指针，每个类只包含一个vptr指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pFunc)</span><span class="params">()</span></span>;</span><br><span class="line">Base base_obj;</span><br><span class="line"><span class="type">void</span> **p_base = (<span class="type">void</span> **)&amp;base_obj;</span><br><span class="line"><span class="type">void</span> **vptr_base = (<span class="type">void</span>**)*p_base;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;base_obj vf 虚函数指针：%p\n&quot;</span>,vptr_base[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;base_obj vg 虚函数指针：%p\n&quot;</span>,vptr_base[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">pFunc pf = (pFunc)vptr_base[<span class="number">0</span>];</span><br><span class="line">pFunc pg = (pFunc)vptr_base[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">pf</span>();</span><br><span class="line"><span class="built_in">pg</span>();</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pFunc)</span><span class="params">()</span></span>;</span><br><span class="line">Derived derived_obj;</span><br><span class="line"><span class="type">void</span> **p_base = (<span class="type">void</span> **)&amp;derived_obj;</span><br><span class="line"><span class="type">void</span> **vptr_base = (<span class="type">void</span>**)*p_base;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;derived_obj vf 虚函数指针：%p\n&quot;</span>,vptr_base[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;derived_obj vg 虚函数指针：%p\n&quot;</span>,vptr_base[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;derived_obj vf1 虚函数指针:%p\n&quot;</span>,vptr_base[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;derived_obj vg1 虚函数指针:%p\n&quot;</span>,vptr_base[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">pFunc pf = (pFunc)vptr_base[<span class="number">0</span>];</span><br><span class="line">pFunc pg = (pFunc)vptr_base[<span class="number">1</span>];</span><br><span class="line">pFunc vf1 = (pFunc)vptr_base[<span class="number">2</span>];</span><br><span class="line">pFunc vg1 = (pFunc)vptr_base[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">pf</span>();</span><br><span class="line"><span class="built_in">pg</span>();</span><br><span class="line"><span class="built_in">vf1</span>();</span><br><span class="line"><span class="built_in">vg1</span>();</span><br></pre></td></tr></table></figure>



<p>我们可以清楚的看到，在派生类的虚函数表中，优先存储的是基类的虚函数指针，然后再存储派生类的虚函数指针（按函数声明顺序），而且在派生类的虚函数表中，存储的继承自基类的虚函数指针与基类中存储的虚函数指针完全一致</p>
<p><img src="https://img-blog.csdnimg.cn/20210524145140467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWxhbmdfemhpenVu,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4 id="派生类重写了基类的虚函数"><a href="#派生类重写了基类的虚函数" class="headerlink" title="派生类重写了基类的虚函数"></a>派生类重写了基类的虚函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;virtual Base::vf&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vg</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;virtual Base::vg&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> base_m1 , base_m2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;virtual Derived::vf&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vg</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;virtual Derived::vg&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> derived_m1 , derived_m2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>通过打印的地址，我们可以清楚的看到，当派生类重写了基类的虚函数时，虚函数表中存放的虚函数指针是不一样的，因为编译器给重写的虚函数重新分配了内存空间。</p>
<p><img src="https://img-blog.csdnimg.cn/20210524151821994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWxhbmdfemhpenVu,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>以此类推，那如果派生类只重写了基类的部分虚函数呢？</p>
<h4 id="派生类重写了基类的部分虚函数"><a href="#派生类重写了基类的部分虚函数" class="headerlink" title="派生类重写了基类的部分虚函数"></a>派生类重写了基类的部分虚函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Base::vf&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vg</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Base::vg&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base_m1,base_m2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Derived::vf&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vg1</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Derived::vg&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derived_m1 , derived_m2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p><img src="https://img-blog.csdnimg.cn/20210524153014451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWxhbmdfemhpenVu,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><h4 id="普通类的多重继承"><a href="#普通类的多重继承" class="headerlink" title="普通类的多重继承"></a>普通类的多重继承</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> base_m1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseB</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> base_m2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> derived_m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Derived obj;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(Derived) = %d\n&quot;</span>,<span class="built_in">sizeof</span>(Derived));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;对象地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;derived_obj \t addr: 0x%p\n&quot;</span>, &amp;obj);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\n成员变量地址 -------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以，这种模式的内存分配模型为</p>
<p><img src="https://img-blog.csdnimg.cn/2021052416065136.png" alt="img"></p>
<h4 id="含有虚函数的类的多重继承"><a href="#含有虚函数的类的多重继承" class="headerlink" title="含有虚函数的类的多重继承"></a>含有虚函数的类的多重继承</h4><p>含有虚函数的类的多重继承，和前面提到的虚函数的单继承有很大的不同，现有如下基类定义 后面的例子将都基于此处定义的两个基类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;virtual BaseA::vf&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> base_m1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseB</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vg</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;virtual BaseB::vg&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> base_m2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="派生类重写了所有基类的虚函数"><a href="#派生类重写了所有基类的虚函数" class="headerlink" title="派生类重写了所有基类的虚函数"></a>派生类重写了所有基类的虚函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Derived::vf&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vg</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Derived::vg&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> derived_m3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived derived_obj;</span><br><span class="line"><span class="type">void</span> **p_vptrB = (<span class="type">void</span> **)((<span class="type">char</span> *)&amp;derived_obj + <span class="built_in">sizeof</span>(BaseA)); <span class="comment">//需加上 sizeof(BaseA) </span></span><br><span class="line"><span class="type">void</span> **vptrB_derived = (<span class="type">void</span> **)*p_vptrB;</span><br><span class="line"> </span><br><span class="line">pFunc pg = (pFunc)vptrB_derived[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;derived_obj vg 虚函数指针: : %p\n&quot;</span>, pg);</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20210524180010257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWxhbmdfemhpenVu,size_16,color_FFFFFF,t_70" alt="img"></p>
<h5 id="派生类未重写基类的虚函数"><a href="#派生类未重写基类的虚函数" class="headerlink" title="派生类未重写基类的虚函数"></a>派生类未重写基类的虚函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf1</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;virtual Derived::vf&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vg1</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;virtual Derived::vg&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> derived_m3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210524180247815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWxhbmdfemhpenVu,size_16,color_FFFFFF,t_70" alt="img"></p>
<h5 id="派生类重写了部分基类的虚函数"><a href="#派生类重写了部分基类的虚函数" class="headerlink" title="派生类重写了部分基类的虚函数"></a>派生类重写了部分基类的虚函数</h5><p>现有如下子类定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Derived::vf&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vg1</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;virtual Derived::vg1&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> derived_m3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20210524181138426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWxhbmdfemhpenVu,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>##关于内存泄漏</p>
<p><img src="https://img-blog.csdnimg.cn/d677b01208734d2e93b02ea07da6b685.png" alt="img"></p>
<p>###背景</p>
<p>C/C++语言中，内存的分配与回收都是由开发人员在编写代码时主动完成的，好处是内存管理的开销较小，程序拥有更高的执行效率；弊端是依赖于开发者的水平，随着代码规模的扩大，极容易遗漏释放内存的步骤，或者一些不规范的编程可能会使程序具有安全隐患。如果对内存管理不当，可能导致程序中存在内存缺陷，甚至会在运行时产生内存故障错误。</p>
<p>内存泄漏时各类缺陷中十分棘手的一种，对系统的稳定运行威胁较大。当动态分配的内存在程序结束之前没有被回收时，则发生了内存泄漏。若存在内存泄漏则会造成严重后果，例如**<code>性能下降、程序终止、系统崩溃、无法提供服务</code>**等。</p>
<p>接下来我们从原因、避免、以及定位几个方面去深入理解。</p>
<p>###概念</p>
<p>当我们在程序中对原始指针(raw pointer)使用**<code>new</code><strong>操作符或者</strong><code>free</code><strong>函数的时候，实际上是在堆上为其分配内存，这个内存指的是RAM，而不是硬盘等永久存储。持续申请而不释放(或者少量释放)内存的应用程序，最终因内存耗尽导致</strong><code>OOM(out of memory)</code>**。OS会进行自我保护，杀掉该进程，这就是我们常说的OOM(OUT OF MEMORY)</p>
<p>###分类</p>
<p>内存泄漏分为一下两类：</p>
<ul>
<li>堆内存泄漏：我们经常说的内存泄漏就是堆内存泄漏，在堆上申请了资源，在结束使用的时候，没有释放归还给OS，从而导致该块内存永远不会被再次使用。</li>
<li>资源泄漏：通常指的是系统资源，比如SOCKET，文件描述符 ，因为这些在系统中都是有限制，如果创建了而不归还，久而久之，就会耗尽资源，导致其他程序不可用。</li>
</ul>
<p>这里主要分析堆内存泄漏，所以后面的内存泄漏均指的是堆内存泄漏。</p>
<p>###根源</p>
<p>内存泄漏，主要指的是在堆上申请的动态内存泄漏，或者说是指针指向的内存块忘了被释放，导致该块内存不能再背申请重新使用。</p>
<p>这一切得从进程的内存布局说起：</p>
<p><img src="https://img-blog.csdnimg.cn/7a52203fabd54d7c949936922e38e610.png" alt="img"></p>
<p>上图为32位进程的内存布局，从上图中主要包含以下几个块：</p>
<ul>
<li>内核空间：供内核使用，存放的是内核代码和数据</li>
<li>stack：这就是我们经常所说的栈，用来存储自动变量</li>
<li>mmap：也成为内存映射，用来在进程虚拟内存地址空间中分配地址空间，创建和物理内存的映射关系。</li>
<li>heap：就是我们常说的堆，动态内存的分配都是在堆上</li>
<li>bss：初始化的数据块<ul>
<li>包含显示式初始化的全局变量和静态变量</li>
<li>此段的大小由程序源代码中值的大小决定，在运行时不会更改</li>
<li>它具有读写权限，因此可以在运行时更改此段的变量值</li>
<li>该段可进一步分为初始化只读区和初始化读写区</li>
</ul>
</li>
<li>text：也称为文本段<ul>
<li>该段包含已编译程序的二进制文件</li>
<li>该段是一个只读段，用于防止程序被意外修改</li>
<li>该段可进一步分为初始化只读区和初始化读写区</li>
</ul>
</li>
</ul>
<p>####栈</p>
<p>栈是一块连续的内存块，栈上的内存分配就是在这一块内存块上进行操作的。编译器在编译的时候，就已经知道要分配的内存大小（ why ？？ 递归函数 动态数组 ？？），当调用函数时，其内部的遍历都会在栈上分配内存；当结束函数调用时候，内部变量就会被释放，进而将内存归还给栈。</p>
<p>堆栈先进后出（FILO）的，而C++语言的实现一般也会使用到堆栈来分配局部变量。因为栈上内存分配和释放，是一个进栈和出站的过程，所以相比于堆上的内存分配，栈要快的多</p>
<p>虽然栈的访问速度要快于堆，每个线程都有一个自己的栈，栈上的对象是不能跨线程访问的，这就决定了栈空间大小是有限制的，如果栈空间过大，那么在大型程序中几十乃至上百个线程，光栈空间就消耗了RAM，这就导致heap的可用空间变小，影响程序正常运行。</p>
<p><img src="https://img-blog.csdnimg.cn/aca6a272ab7b4be8b2ab2bc0244bc3d9.png" alt="img"></p>
<p>分配方式</p>
<ul>
<li>静态分配 </li>
</ul>
<p>静态分配由编译器完成，假如局部变量以及函数参数等，都在编译器就分配好了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，a占10 * sizeof(int)个字节，在编译的时候直接计算好了，运行的时候，直接进栈出栈。</p>
<ul>
<li>动态分配</li>
</ul>
<p>可能很多人认为只有堆上才会存在动态分配，在栈上只可能是静态分配。其实，这个观点是错的，栈上也支持动态分配，该动态分配由alloca（）函数进行分配。栈的动态分配和堆是不同的，通过alloca（）函数进行分配的内存由编译器进行释放，无需手动操作。</p>
<p>特点：</p>
<ol>
<li>分配速度快：分配大小由编译器在编译期完成</li>
<li>不会产生内存碎片：栈内存分配是连续的，以FILO的方式进栈和出栈</li>
<li>大小受限：栈的大小依赖于操作系统</li>
<li>访问受限：只能在当前函数或者作用域内进行访问</li>
</ol>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆是一种内存管理方式。内存管理对操作系统来说是一件非常复杂的事情，因为首先内存容量很大，其次就是内存需求在时间和大小块上没有规律（操作系统上运行着几十甚至几百个进程，这些</p>
<p>#Effective C++</p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>###条款1:理解模版型别推导</p>
<p>一般的函数模版声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"><span class="built_in">fun</span>(expr);</span><br></pre></td></tr></table></figure>

<p>情况一：param是指针或引用，但不是万能引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;fT1: &quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fPtr</span><span class="params">(T* param)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;fT2: &quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/cover2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/15/Linux/"><img class="prev-cover" src="/img/cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Linux</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/17/12-17/"><img class="next-cover" src="/img/cover2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">内存映射</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Valerian</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><!--!=partial('includes/widget/card_announcement', {}, {cache: true})--><div class="card-widget" id="card-poem"><div id="poem_sentence"></div><div id="poem_info"><div id="poem_dynasty"></div><div id="poem_author"></div></div></div><script src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/jinrishici.js" charset="utf-8"></script><script type="text/javascript">jinrishici.load(function(result) {
var sentence = document.querySelector("#poem_sentence")
var author = document.querySelector("#poem_author")
var dynasty = document.querySelector("#poem_dynasty")

var sentenceText = result.data.content
sentenceText = sentenceText.substr(0, sentenceText.length - 1);
sentence.innerHTML = sentenceText
dynasty.innerHTML = result.data.origin.dynasty
author.innerHTML = result.data.origin.author + '《' + result.data.origin.title + '》'
});</script><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">C++程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">构造函数和析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">构造函数调用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">1.1.0.5.</span> <span class="toc-text">类对象作为类成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.1.0.6.</span> <span class="toc-text">静态成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">c++对象模型和this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">成员变量和成员函数分开存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">空指针访问成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">const修饰成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">1.1.2.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">全局函数做友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">类做友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">成员函数做友元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.3.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">左移运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">递增运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">赋值运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">关系运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">函数调用运算重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">类型转换运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">继承的基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.3.8.</span> <span class="toc-text">继承的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.3.9.</span> <span class="toc-text">继承中的对象模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.1.3.10.</span> <span class="toc-text">继承中构造和析构顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.3.11.</span> <span class="toc-text">继承中同名成员处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86"><span class="toc-number">1.1.3.12.</span> <span class="toc-text">同名静态成员处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.3.13.</span> <span class="toc-text">多继承语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.3.14.</span> <span class="toc-text">菱形继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.1.4.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">多态的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%E4%B8%80-%E8%AE%A1%E7%AE%97%E5%99%A8%E7%B1%BB"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">多态案例一 计算器类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">纯虚函数和抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%E4%BA%8C-%E5%88%B6%E4%BD%9C%E9%A5%AE%E5%93%81"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">多态案例二-制作饮品</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">虚析构和纯虚析构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%E4%B8%89-%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">多态案例三 - 电脑组装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.5.</span> <span class="toc-text">文本文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">读文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%BD%AC%E6%8D%A2-static-cast"><span class="toc-number">1.2.1.</span> <span class="toc-text">静态转换(static_cast)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%BD%AC%E6%8D%A2-dynamic-cast"><span class="toc-number">1.2.2.</span> <span class="toc-text">动态转换(dynamic_cast)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%BD%AC%E6%8D%A2-const-cast"><span class="toc-number">1.2.3.</span> <span class="toc-text">常量转换(const_cast)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%A7%A3%E9%87%8A%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.4.</span> <span class="toc-text">重新解释转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.</span> <span class="toc-text">C++异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">异常基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%BC%82%E5%B8%B8%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">C++异常基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E8%A7%A3%E6%97%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">栈解旋</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%A5%E6%A0%BC%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D"><span class="toc-number">1.3.4.</span> <span class="toc-text">异常的严格类型匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="toc-number">1.3.5.</span> <span class="toc-text">异常接口声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">异常变量的声明周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%9A%E6%80%81%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.7.</span> <span class="toc-text">异常的多态使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8%E5%BA%93"><span class="toc-number">1.3.8.</span> <span class="toc-text">标准异常库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">1.3.9.</span> <span class="toc-text">编写自己的异常类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9Aregex%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%80%89%E9%A1%B9"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">指定regex对象的选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.10.</span> <span class="toc-text">反射的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.11.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.12.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-number">1.3.12.0.1.</span> <span class="toc-text">方案一</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">C++泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%89%88"><span class="toc-number">2.1.</span> <span class="toc-text">模版</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">模版的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88"><span class="toc-number">2.1.2.</span> <span class="toc-text">函数模版</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">函数模版语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">函数模版注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E6%A1%88%E4%BE%8B"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">函数模版案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">普通函数和函数模版的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E7%9A%84%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">普通函数和函数模版的调用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">2.1.2.6.</span> <span class="toc-text">模版的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88"><span class="toc-number">2.1.3.</span> <span class="toc-text">类模版</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">类模版语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E5%92%8C%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">类模版和函数模版的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">类模版中的成员函数创建时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">类模版对象做函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.3.5.</span> <span class="toc-text">类模版与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.3.6.</span> <span class="toc-text">类模版成员函数类外实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="toc-number">2.1.3.7.</span> <span class="toc-text">类模版分文件编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E4%B8%8E%E5%8F%8B%E5%85%83"><span class="toc-number">2.1.3.8.</span> <span class="toc-text">类模版与友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88%E6%A1%88%E4%BE%8B"><span class="toc-number">2.1.3.9.</span> <span class="toc-text">类模版案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%88%9D%E8%AF%86"><span class="toc-number">2.2.</span> <span class="toc-text">STL初识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">STL的诞生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.2.</span> <span class="toc-text">STL的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">STL六大组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.4.</span> <span class="toc-text">STL-常见容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">string容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.4.1.1.</span> <span class="toc-text">string基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.4.1.2.</span> <span class="toc-text">string构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E7%9A%84%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.4.1.3.</span> <span class="toc-text">string的赋值操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">2.2.4.1.4.</span> <span class="toc-text">string字符串拼接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">string查找和替换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.4.2.1.</span> <span class="toc-text">string字符串比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E5%AD%98%E5%8F%96"><span class="toc-number">2.2.4.2.2.</span> <span class="toc-text">string字符存取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.4.2.3.</span> <span class="toc-text">string插入和删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E5%AD%90%E4%B8%B2"><span class="toc-number">2.2.4.2.4.</span> <span class="toc-text">string子串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">vector容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.4.3.1.</span> <span class="toc-text">vector构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.4.3.2.</span> <span class="toc-text">vector赋值操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.2.4.3.3.</span> <span class="toc-text">vector容量和大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.4.3.4.</span> <span class="toc-text">vector插入和删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">2.2.4.3.5.</span> <span class="toc-text">vector数据存取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.4.3.6.</span> <span class="toc-text">vector互换容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4"><span class="toc-number">2.2.4.3.7.</span> <span class="toc-text">vector预留空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#emplace-back"><span class="toc-number">2.2.4.3.8.</span> <span class="toc-text">emplace_back</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">deque容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.4.4.1.</span> <span class="toc-text">deque容器基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.4.4.2.</span> <span class="toc-text">deque构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.4.4.3.</span> <span class="toc-text">deque赋值操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.4.4.4.</span> <span class="toc-text">deque大小操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">set&#x2F;multiset容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.4.5.1.</span> <span class="toc-text">set插入和删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.2.4.5.2.</span> <span class="toc-text">set容器的查找和统计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pair%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.4.5.3.</span> <span class="toc-text">pair对组创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">2.2.4.5.4.</span> <span class="toc-text">set容器的排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-multimap-%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.4.6.</span> <span class="toc-text">map&#x2F;multimap 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#map%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">2.2.4.6.1.</span> <span class="toc-text">map构造和赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#map%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.2.4.6.2.</span> <span class="toc-text">map大小和交换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#map%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.4.6.3.</span> <span class="toc-text">map插入和删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#map%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.2.4.6.4.</span> <span class="toc-text">map的查找和统计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#map%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">2.2.4.6.5.</span> <span class="toc-text">map容器排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-map"><span class="toc-number">2.2.4.7.</span> <span class="toc-text">unordered_map</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#unordered-map%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%9A%84HASH%E8%BF%90%E7%AE%97"><span class="toc-number">2.2.4.7.1.</span> <span class="toc-text">unordered_map对自定义类型的HASH运算</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.</span> <span class="toc-text">函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">基本概念和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%93%E8%AF%8D"><span class="toc-number">2.3.2.</span> <span class="toc-text">谓词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">一元谓词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">二元谓词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.3.</span> <span class="toc-text">内建函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">算术仿函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">关系仿函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">逻辑仿函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">C++新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">3.1.</span> <span class="toc-text">类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">3.1.1.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E8%B8%AA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">追踪返回类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%93%E7%94%A8%E6%80%A7%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">3.2.</span> <span class="toc-text">易用性的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.2.1.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%86%85%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">类内成员初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">列表初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">类型收窄</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80"><span class="toc-number">3.2.2.</span> <span class="toc-text">静态断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#noexcept%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.2.3.</span> <span class="toc-text">noexcept修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.2.4.</span> <span class="toc-text">常量表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.2.5.</span> <span class="toc-text">用户自定义字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">3.2.6.</span> <span class="toc-text">原生字符串字面值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">3.3.</span> <span class="toc-text">类的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0"><span class="toc-number">3.3.1.</span> <span class="toc-text">继承构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0"><span class="toc-number">3.3.2.</span> <span class="toc-text">委托构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%8E%A7%E5%88%B6%EF%BC%9Afinal%E5%92%8Coverride"><span class="toc-number">3.3.3.</span> <span class="toc-text">继承控制：final和override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A7%E5%88%B6%EF%BC%9Adefault%E5%87%BD%E6%95%B0%E5%92%8Cdelete%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.4.</span> <span class="toc-text">类默认函数的控制：default函数和delete函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#default"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">default</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">delete</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-number">3.3.5.</span> <span class="toc-text">模版的别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E7%9A%84%E6%A8%A1%E7%89%88%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.6.</span> <span class="toc-text">函数默认的模版参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%85%E7%9A%84%E5%B1%95%E5%BC%80"><span class="toc-number">3.3.7.</span> <span class="toc-text">参数包的展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E7%89%88%E7%B1%BB"><span class="toc-number">3.3.8.</span> <span class="toc-text">可变参数模版类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.</span> <span class="toc-text">右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">左值引用、右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">3.4.2.</span> <span class="toc-text">移动语义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%AE%9A%E4%B9%89"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">移动语义定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">转移赋值函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0-std-move"><span class="toc-number">3.4.3.</span> <span class="toc-text">标准库函数 std::move</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91-std-forward"><span class="toc-number">3.4.4.</span> <span class="toc-text">完美转发 std::forward</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.5.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">3.5.1.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-number">3.5.2.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">3.5.3.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.6.</span> <span class="toc-text">闭包的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-number">3.6.1.</span> <span class="toc-text">什么是闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%9A%E9%87%8D%E8%BD%BDoperator%EF%BC%88%EF%BC%89"><span class="toc-number">3.6.2.</span> <span class="toc-text">仿函数：重载operator（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-bind%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-number">3.6.3.</span> <span class="toc-text">std::bind绑定器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">函数表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-function"><span class="toc-number">3.6.3.2.</span> <span class="toc-text">std::function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-bind"><span class="toc-number">3.6.3.3.</span> <span class="toc-text">std::bind</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.6.4.</span> <span class="toc-text">lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">lambda基础使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">lambda表达式与仿函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.4.3.</span> <span class="toc-text">lambda类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%E5%88%9D%E8%AF%86"><span class="toc-number">3.6.5.</span> <span class="toc-text">constexpr初识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-constexpr"><span class="toc-number">3.6.6.</span> <span class="toc-text">if constexpr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr-virtual-%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.7.</span> <span class="toc-text">constexpr virtual 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Concept%E6%A6%82%E5%BF%B5"><span class="toc-number">3.7.</span> <span class="toc-text">Concept概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E5%BC%95%E5%85%A5Concept"><span class="toc-number">3.7.1.</span> <span class="toc-text">为何要引入Concept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFConcept%EF%BC%9F"><span class="toc-number">3.7.2.</span> <span class="toc-text">什么是Concept？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8STL%E5%B7%A5%E5%85%B7%E6%9D%A5%E5%81%9AConcept"><span class="toc-number">3.7.3.</span> <span class="toc-text">使用STL工具来做Concept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Concept%E5%9D%97"><span class="toc-number">3.7.4.</span> <span class="toc-text">Concept块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E5%AE%9A%E4%B9%89Concept"><span class="toc-number">3.7.5.</span> <span class="toc-text">独立定义Concept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7%E7%9A%84concept"><span class="toc-number">3.7.6.</span> <span class="toc-text">更加强大的concept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.7.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SFINAE"><span class="toc-number">3.8.</span> <span class="toc-text">SFINAE</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">C++并发与多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E5%B9%B6%E5%8F%91"><span class="toc-number">4.1.</span> <span class="toc-text">第一节：并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">并发的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">进程与可执行程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E3%80%81%E7%BB%93%E6%9D%9F"><span class="toc-number">4.2.</span> <span class="toc-text">第二节线程启动、结束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">线程运行的开始和结束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82"><span class="toc-number">4.3.</span> <span class="toc-text">第三节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">C++设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Prototype%EF%BC%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">原型模式（Prototype）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">6.</span> <span class="toc-text">C++内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">6.1.</span> <span class="toc-text">类中的内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">6.1.1.</span> <span class="toc-text">普通类对象的内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">6.1.2.</span> <span class="toc-text">含有虚函数的类对象的内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">6.1.3.</span> <span class="toc-text">含有虚函数的派生类的内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%B2%A1%E6%9C%89%E9%87%8D%E5%86%99%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">派生类没有重写基类的虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E9%87%8D%E5%86%99%E4%BA%86%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">派生类重写了基类的虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E9%87%8D%E5%86%99%E4%BA%86%E5%9F%BA%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">派生类重写了基类的部分虚函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">6.1.4.</span> <span class="toc-text">多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">普通类的多重继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">6.1.4.2.</span> <span class="toc-text">含有虚函数的类的多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E9%87%8D%E5%86%99%E4%BA%86%E6%89%80%E6%9C%89%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.4.2.1.</span> <span class="toc-text">派生类重写了所有基类的虚函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9C%AA%E9%87%8D%E5%86%99%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.4.2.2.</span> <span class="toc-text">派生类未重写基类的虚函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E9%87%8D%E5%86%99%E4%BA%86%E9%83%A8%E5%88%86%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.4.2.3.</span> <span class="toc-text">派生类重写了部分基类的虚函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">6.1.4.3.</span> <span class="toc-text">堆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-number">6.2.</span> <span class="toc-text">第一章</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/17/12-17/" title="内存映射"><img src="/img/cover2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内存映射"/></a><div class="content"><a class="title" href="/2022/12/17/12-17/" title="内存映射">内存映射</a><time datetime="2022-12-17T12:31:27.000Z" title="Created 2022-12-17 20:31:27">2022-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/15/C/" title="C++"><img src="/img/cover2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++"/></a><div class="content"><a class="title" href="/2022/12/15/C/" title="C++">C++</a><time datetime="2022-12-15T13:09:45.000Z" title="Created 2022-12-15 21:09:45">2022-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/15/Linux/" title="Linux"><img src="/img/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux"/></a><div class="content"><a class="title" href="/2022/12/15/Linux/" title="Linux">Linux</a><time datetime="2022-12-15T13:03:49.000Z" title="Created 2022-12-15 21:03:49">2022-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/18/%E4%B8%BB%E9%A2%98%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD/" title="主题特殊功能"><img src="/img/cover1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="主题特殊功能"/></a><div class="content"><a class="title" href="/2022/10/18/%E4%B8%BB%E9%A2%98%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD/" title="主题特殊功能">主题特殊功能</a><time datetime="2022-10-18T01:50:38.157Z" title="Created 2022-10-18 09:50:38">2022-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/15/hello-world/" title="Hello World"><img src="/img/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/10/15/hello-world/" title="Hello World">Hello World</a><time datetime="2022-10-15T11:04:31.362Z" title="Created 2022-10-15 19:04:31">2022-10-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Valerian</div><div class="footer_custom_text">Hi Anonymous,Welcome to my <a target="_blank" rel="noopener" href="https://valerianding.github.io">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="/js/footer.js"></script><script async src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/categoryBar/categoryBar.js"></script></div></body></html>