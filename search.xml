<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux</title>
      <link href="/2022/12/15/Linux/"/>
      <url>/2022/12/15/Linux/</url>
      
        <content type="html"><![CDATA[<p>#Linux多进程开发</p><p>进程</p><p>程序入口地址：标识程序开始执行时的起始指令位置</p><p>单道程序 即在计算机内存中只允许一个的程序运行</p><p>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使他们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态，这些程序共享计算机系统资源，目的是为了提高CPU的利用率</p><p>对与一个单CPU系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU上运行的程序只有一个</p><p>在多道程序设计模型中，多个进程轮流使用CPU。而当下常见CPU为纳秒级，1秒可以执行10亿条机器指令</p><p>时间片 又称为量子 或 处理器片 是操作系统分配给每个正在运行的进程微观上的一段CPU时间，时间片通常很短（Linux上为5ms-800ms）用户不会感觉到</p><p>时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应地时间。当所有进程都处于时间片耗尽状态时，内核会重新为每个进程计算并分配时间片，如此往复。</p><p>并行：指在同一时刻，有多条指令在多个处理器上同时执行</p><p>并发：同一时刻只能有一条指令执行 但多个进程指令被快速的轮换执行 使得在宏观上具有多个进程同时执行的效果，但在微观上不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行</p><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个PCB进程控制块，维护进程相关的信息，Linux内核的进程控制块是task_struct 结构体</p><p>task_struct 内部成员有很多，我们只需要掌握下部分即可</p><p>进程id 系统中每个进程有唯一的id，用pid_t 类型表示，其实就是一个非负整数</p><p>进程的状态：有就绪、运行、挂起、停止等状态</p><p>进程切换时需要保存和恢复的一些CPU寄存器</p><p>描述虚拟地址空间的信息</p><p>描述控制终端的信息</p><p>当前的工作目录</p><p>umask 掩码</p><p>文件描述符表 包含很多指向file结构体的指针</p><p>和信号相关的信息</p><p>用户id和组id</p><p>会话和进程组</p><p>进程可以使用的资源上线</p><p>阻塞态：指进程不具备运行条件，正在等待某个时间的完成</p><p>新建态：进程刚被创建是时的状态，尚未进入就绪队列</p><p>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行。但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</p><p>孤儿进程：</p><p>父进程运行结束，但子进程还在运行，这样的子进程就称为孤儿进程</p><p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init（pid = 1）进程会循环地wait()它的已经退出的子进程 去释放它的资源。这样当一个孤儿进程结束了其生命周期的时候，init进程就会处理。</p><p>因此孤儿进程并不会有什么危害。</p><p>僵尸进程：</p><p>每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的PCB没有办法释放掉，需要父进程去释放 </p><p>子进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，编程僵尸进程。</p><p>（由于子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程 到底什么时候结束. 那么会不会因为父进程太忙来不及wait子进程，或者说不知道 子进程什么时候结束，而丢失子进程结束时的状态信息呢? 不会。因为UNⅨ提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是： 在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）。直到父进程通过wait / waitpid来取时才释放. 但这样就导致了问题，如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免）</p><p>僵尸进程不能被kill -9 杀死</p><p>这样就会导致一个问题，如果父进程不调用wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应答避免。</p><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要是指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）</p><p>父进程可以通过调用wait或waitpid得到它的推出状态同时彻底清掉这个进程。</p><p>wait和waitpid函数的功能一样，区别在于wait函数会阻塞，waitpid可以设置不阻塞，waitpid还可以指定等待哪个子进程结束。</p><p>注意：一次wait或waitpid调用只能清理一个子进程，清多个子进程应使用循环。</p><p>进程间通信/通讯</p><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是的用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p><p>但是，进程不是孤立的，不同进程需要进行信息的交互和状态的传递等，因此需要进程间通信（IPC:Inter Processes Communication）</p><p>进程间通信的目的：</p><p>​    数据传输：一个进程需要将它的数据发送给另一个进程。</p><p>​    通知事件：一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件</p><p>​    资源共享：多个进程之间共享同样的资源，为了做到这一点，需要内核提供互斥和同步机制。</p><p>​    进程控制：有些进程希望完全控制另一个进程的执行（DEBUG），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够知道它的状态</p><p>​    ![Screen Shot 2022-11-18 at 2.23.38 PM](/Users/valerian/Desktop/Screen Shot 2022-11-18 at 2.23.38 PM.png)</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><ol><li>简介</li></ol><ul><li>管道也叫无名（匿名）管道，它是UNIX系统IPC的最古老形式，所有的UNIX系统都支持这种通信机制</li><li>统计一个目录中文件的数目命令 : ls | wc - 1,为了执行该命令，shell创建了两个进程来执行ls和wc 中间的‘｜’叫做管道符![Screen Shot 2022-11-18 at 4.11.31 PM](/Users/valerian/Library/Application Support/typora-user-images/Screen Shot 2022-11-18 at 4.11.31 PM.png)</li></ul><ol start="2"><li>特点</li></ol><ul><li>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同</li><li>管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作（匿名管道一般是有关系进程 有名管道对应的无关系的进程）</li><li>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概率，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小时多少</li><li>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。（环形的队列）![Screen Shot 2022-11-18 at 5.30.01 PM](/Users/valerian/Library/Application Support/typora-user-images/Screen Shot 2022-11-18 at 5.30.01 PM.png)</li><li>管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。（同时只能往一个方向）</li><li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用lseek()来随机的访问数据。</li><li>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</li></ul><p>![Screen Shot 2022-11-18 at 5.15.42 PM](/Users/valerian/Library/Application Support/typora-user-images/Screen Shot 2022-11-18 at 5.15.42 PM.png)</p><ol start="3"><li>为什么匿名管道能实现信息通讯</li></ol><p>![Screen Shot 2022-11-18 at 5.28.45 PM](/Users/valerian/Library/Application Support/typora-user-images/Screen Shot 2022-11-18 at 5.28.45 PM.png)</p><ol start="4"><li>匿名管道的使用</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES </span></span><br><span class="line"><span class="comment">    struct fd_pair &#123;</span></span><br><span class="line"><span class="comment">        long fd[2];</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    struct fd_pair pipe();</span></span><br><span class="line"><span class="comment">    int pipe(int pipefd[2]);</span></span><br><span class="line"><span class="comment">        功能：创建一个匿名管道用于进程间的匿名通信，用来进程间通信</span></span><br><span class="line"><span class="comment">        参数：int pipefd[2] 这个数组是一个传出参数。</span></span><br><span class="line"><span class="comment">            pipefd[0] 对应的是管道的读端</span></span><br><span class="line"><span class="comment">            pipefd[1] 对应的是管道的写端</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            如果成功返回0 失败返回-1</span></span><br><span class="line"><span class="comment">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了,write阻塞</span></span><br><span class="line"><span class="comment">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span></span><br><span class="line"><span class="comment">    通常情况下两个进程一般不会</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pipe</span>(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要创建子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>(pipefd[<span class="number">0</span>],buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid = %d\n&quot;</span>,buf,<span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// char* str = &quot;hello,I am parent&quot;;</span></span><br><span class="line">            <span class="comment">// write(pipefd[1],str,strlen(str));</span></span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid: %d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;hello,I am child&quot;</span>;</span><br><span class="line">            <span class="built_in">write</span>(pipefd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line">            <span class="comment">// int len = read(pipefd[0],buf,sizeof(buf));</span></span><br><span class="line">            <span class="comment">// printf(&quot;child recv : %s, pid = %d\n&quot;,buf,getpid());</span></span><br><span class="line">            <span class="comment">// bzero(buf,1024,0);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道的读写特点"><a href="#管道的读写特点" class="headerlink" title="管道的读写特点"></a>管道的读写特点</h3><p>使用管道时需要注意以下几种特殊的情况（假设都是阻塞I/O操作）</p><ol><li><p>所有的指向管道写端的文件描述符都关闭了 （管道的写端引用计数为0）有进程从管道中读数据，管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样</p></li><li><p>如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</p></li><li><p>如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数等于0）如果这个时候有进程向管道中写数据，那么该进程（写进程）会收到一个信号SIGPIPE，通常会导致进程异常终止</p></li><li><p>如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0）而持有管道读端的进程没有从管道中读数据，这时有进程向管道中写数据，那么管道被写满的时候，再次调用write会j n阻塞，直到管道中有空位置才能再次写入数据并返回。</p></li></ol><p>总结：</p><p>读数据：</p><ul><li><p>管道中有数据，read返回0（相当于读到文件的结尾）</p></li><li><p>管道中无数据：</p><ol><li>写端没有完全关闭 read阻塞等待</li><li>写端被全部关闭 read返回0（相当于读到了文件的末尾）</li></ol></li></ul><p>写数据：</p><ul><li>管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）</li><li>管道读端没有全部关闭：<ol><li>管道已满，write阻塞</li><li>管道没有满 write将数据写入，并返回实际写入的字节数</li></ol></li></ul><p>###设置管道为非阻塞</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置管道非阻塞</span></span><br><span class="line"><span class="comment">    int flags = fcntl(fd[0],F_GETFLAG); 获取原来的flag</span></span><br><span class="line"><span class="comment">    flags |= O_NONBLOCK  修改flag的值</span></span><br><span class="line"><span class="comment">    fcntl(fd[0],F_SETFL,flags) 设置新的flag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pipe</span>(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要创建子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> flags = <span class="built_in">fcntl</span>(pipefd[<span class="number">0</span>],F_GETFL);</span><br><span class="line">        flags |= O_NONBLOCK;</span><br><span class="line">        <span class="built_in">fcntl</span>(pipefd[<span class="number">0</span>],F_SETFL,flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>(pipefd[<span class="number">0</span>],buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;len : %d\n&quot;</span>,len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid = %d\n&quot;</span>,buf,<span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid: %d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;hello,I am child&quot;</span>;</span><br><span class="line">            <span class="built_in">write</span>(pipefd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">            <span class="comment">// int len = read(pipefd[0],buf,sizeof(buf));</span></span><br><span class="line">            <span class="comment">// printf(&quot;child recv : %s, pid = %d\n&quot;,buf,getpid());</span></span><br><span class="line">            <span class="comment">// bzero(buf,1024,0);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有名管道-mkfifo"><a href="#有名管道-mkfifo" class="headerlink" title="有名管道 mkfifo"></a>有名管道 mkfifo</h3><p>内核中的缓冲区具有标识符（标识符是一个可见于文件系统的管道文件），其他进程可以通过这个标识符，找到这块缓冲区（通过打开同一个管道文件，访问到同一块缓冲区），进而实现通信</p><ul><li>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO）, 也叫命名管道、FIFO文件。</li><li>有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO互相通信，因此，通过FIFO不相关的进程也能交换数据。</li><li>一旦打开了FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用了(如read( )、write( )和close( ))。与管道一样，FIFO也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO的名字也由此而来：先入先出。</li></ul><p>但是值得注意的是：</p><ul><li>创建一个命名管道时，不会开辟一块缓冲区，因为创建管道只是创建了一个标识符，真正有进程去打开这个管道的时候，才会开辟空间，因为如果直接开辟一块内存但是一直没有进程打开的时候，就会浪费</li></ul><h3 id="有名管道和匿名管道的不同"><a href="#有名管道和匿名管道的不同" class="headerlink" title="有名管道和匿名管道的不同"></a>有名管道和匿名管道的不同</h3><ul><li>FIFO在文件系统中作为一个特殊文件存在，但FIFO中的内容却存放在内存中</li><li>当使用FIFO中的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用</li><li>FIFO有名字，不相关的进程可以通过打开有名管道进行通信。</li></ul><h3 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a>有名管道的使用</h3><ul><li>通过命令创建有名管道</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfifo 名字</span><br></pre></td></tr></table></figure><p>![Screen Shot 2022-11-22 at 8.19.49 PM](/Users/valerian/Library/Application Support/typora-user-images/Screen Shot 2022-11-22 at 8.19.49 PM.png)</p><ul><li>通过函数创建有名管道</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可以用fifo。如：close、read、write、unlink等</li><li>FIFO严格遵循先进先出(First in First out)，对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek( )等文件定位操作。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建fifo文件</span></span><br><span class="line"><span class="comment">    1.通过命令： mkfifo 名字</span></span><br><span class="line"><span class="comment">    2.通过函数： int mkfifo(const char *pathname,mode_t mode);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname：管道名称的路径</span></span><br><span class="line"><span class="comment">            - mode 文件的权限 和 open的mode是一样的</span></span><br><span class="line"><span class="comment">                   是一个八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0 失败返回-1 设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//int mkfifo(const char *pathname,mode_t mode)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret1 = <span class="built_in">access</span>(<span class="string">&quot;fifo1&quot;</span>,F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在 创建管道ing\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo1&quot;</span>,<span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道已存在\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现两个进程间使用有名管道进行通信</li></ul><p>write.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.判断管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret1 = access(<span class="string">&quot;test&quot;</span>,F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret1 == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在 创建管道ing\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建管道文件 名字叫做test</span></span><br><span class="line">        <span class="type">int</span> ret = mkfifo(<span class="string">&quot;test&quot;</span>,<span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.以只写的方式 打开管道</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test&quot;</span>,O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello, %d\n&quot;</span>,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data : %s\n&quot;</span>,buf);</span><br><span class="line">        write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. open打开管道文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">       <span class="type">int</span> len = read(fd,buf,<span class="keyword">sizeof</span>(buf)); </span><br><span class="line">       <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写端断开链接了...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;recv buf : %s\n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有名管道的注意事项"><a href="#有名管道的注意事项" class="headerlink" title="有名管道的注意事项"></a>有名管道的注意事项</h3><p>1.阻塞</p><pre><code>1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为写打开管道2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</code></pre><p>2.读管道</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">管道中有数据，read返回实际读到的字节数</span><br><span class="line">管道中无数据：</span><br><span class="line">  管道写端被全部关闭，read返回<span class="number">0</span>，（相当于读到文件末尾）</span><br><span class="line">  写端没有完全关闭，read</span><br></pre></td></tr></table></figure><p>3.写管道</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">管道读端被关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="line">管道读端没有全部关闭：</span><br><span class="line">  管道已经满了，write会阻塞</span><br><span class="line">  管道没有满，write将数据写入，并返回实际写入的字节数</span><br></pre></td></tr></table></figure><p>这里看到网上有人装逼说<code>管道读写的原子性</code>所以上网搜索了一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>自我思考</p><ol><li>管道的实现？</li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>主题特殊功能</title>
      <link href="/2022/10/18/%E4%B8%BB%E9%A2%98%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD/"/>
      <url>/2022/10/18/%E4%B8%BB%E9%A2%98%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="links链接块"><a href="#links链接块" class="headerlink" title="links链接块"></a><code>links</code>链接块</h3><p>本功能参考 NexT，基于 Hexo Tag 功能，用来建立友链或其他网址链接功能。 文章中的使用格式：</p><ol><li><p>使用 <code>links</code> 标签块，包围 <code>yml</code> 语法书写的内容，字段包括</p><table><thead><tr><th>属性</th><th align="left">解释</th><th>是否必填</th></tr></thead><tbody><tr><td><code>site</code></td><td align="left">站点名称</td><td>必填</td></tr><tr><td><code>owner</code></td><td align="left">管理员名字</td><td>可选，默认为 <code>site</code> 的值</td></tr><tr><td><code>url</code></td><td align="left">站点链接</td><td>必填</td></tr><tr><td><code>desc</code></td><td align="left">站点描述</td><td>可选，默认为 <code>url</code> 的值</td></tr><tr><td><code>image</code></td><td align="left">站点图片</td><td>可选，默认为 <code>images/404.png</code></td></tr><tr><td><code>color</code></td><td align="left">方块颜色</td><td>可选，默认为 <code>#666</code></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;#123;% links %&amp;#125;</span><br><span class="line">- site: #站点名称</span><br><span class="line">  owner: #管理员名字</span><br><span class="line">  url: #站点网址</span><br><span class="line">  desc: #简短描述</span><br><span class="line">  image: #一张图片</span><br><span class="line">  color: #颜色代码</span><br><span class="line">&amp;#123;% endlinks %&amp;#125;</span><br></pre></td></tr></table></figure><p>:warning:&#123; 和 &#125;是特殊字符，在markdown里书写要用转义字符。&#123; 写成<code>&amp;#123;</code>，&#125;把3改成5即可</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;#123;% links %&amp;#125;</span><br><span class="line">- site: Be rich &amp; free</span><br><span class="line">  owner: Linnie</span><br><span class="line">  url: https://60saint.github.io/</span><br><span class="line">  desc: Linnie的主页</span><br><span class="line">  image: images/avatar.jpg</span><br><span class="line">  color: &quot;#e9546b&quot;</span><br><span class="line"></span><br><span class="line">- site: 優萌初華</span><br><span class="line">  owner: 霜月琉璃</span><br><span class="line">  url: https://shoka.lostyu.me</span><br><span class="line">  image: https://cdn.jsdelivr.net/gh/amehime/shoka@latest/images/IMG_0042.jpg</span><br><span class="line"></span><br><span class="line">- site: 優萌初華</span><br><span class="line">  url: https://shoka.lostyu.me</span><br><span class="line">  desc: 琉璃的医学 &amp; 编程笔记</span><br><span class="line">  color: &quot;#9d5b8b&quot;</span><br><span class="line">&amp;#123;% endlinks %&amp;#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="code代码块"><a href="#code代码块" class="headerlink" title="code代码块"></a><code>code</code>代码块</h3><p>使用 <code>markdown-it-prism</code> 进行代码高亮，支持显示行号、行高亮 <code>mark</code> 、命令行提示符 <code>command</code> 、代码块标题。 </p><p>基本格式： <code>[language] [title] [url] [link text] [mark] [command]</code></p><table><thead><tr><th><strong>选项</strong></th><th><strong>描述</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>language</td><td>如果不需要代码高亮，但希望显示代码块样式，则设为 <code>raw</code>（支持的语言<a href="https://prismjs.com/#supported-languages">戳此</a>）</td><td>null</td></tr><tr><td>title</td><td>代码块的标题文字</td><td>null</td></tr><tr><td>url</td><td>代码块标题右侧显示的链接</td><td>null</td></tr><tr><td>link text</td><td>上述链接显示的标题</td><td>link</td></tr><tr><td>mark</td><td>行高亮显示，格式为 <code>mark:行号,行号开始-行号结束,其他行号</code> （例如 <code>mark:1,4-7,10</code> ，将高亮显示第 1、4、5、6、7、10 行）</td><td>null</td></tr><tr><td>command</td><td>命令行提示符，格式为 <code>command:(&quot;提示内容&quot;:行号,行号&quot;提示内容&quot;:行号开始-行号结束)</code>。 例如 `command:(“[root@localhost] $”:1,9-10</td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```java 行高亮 https://shoka.lostyu.me 参考链接 mark:1,6-7</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">...</span><br><span class="line">Scanner in = new Scanner (System.in);</span><br><span class="line">// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。</span><br><span class="line"></span><br><span class="line">System.out.println (in.nextLine ());</span><br><span class="line">System.out.println (&quot;Hello&quot; + &quot;world.&quot;);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```bash 命令行提示符 command:(&quot;[root@localhost] $&quot;:1,9-10||&quot;[admin@remotehost] #&quot;:4-6)</span><br><span class="line">pwd</span><br><span class="line">/usr/home/chris/bin</span><br><span class="line">ls -la</span><br><span class="line">total 2</span><br><span class="line">drwxr-xr-x   2 chris  chris     11 Jan 10 16:48 .</span><br><span class="line">drwxr--r-x  45 chris  chris     92 Feb 14 11:10 ..</span><br><span class="line">-rwxr-xr-x   1 chris  chris    444 Aug 25  2013 backup</span><br><span class="line">-rwxr-xr-x   1 chris  chris    642 Jan 17 14:42 deploy</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;update&quot;</span><br><span class="line">git push</span><br><span class="line">```</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>行高亮</span><a href="https://shoka.lostyu.me">参考链接 mark:1,6-7</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">...</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span> (System.in);</span><br><span class="line"><span class="comment">// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。</span></span><br><span class="line"></span><br><span class="line">System.out.println (in.nextLine ());</span><br><span class="line">System.out.println (<span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;world.&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>命令行提示符 command:("[root@localhost] $":1,9-10||"[admin@remotehost] #":4-6)</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br><span class="line">/usr/home/chris/bin</span><br><span class="line"><span class="built_in">ls</span> -la</span><br><span class="line">total 2</span><br><span class="line">drwxr-xr-x   2 chris  chris     11 Jan 10 16:48 .</span><br><span class="line">drwxr--r-x  45 chris  chris     92 Feb 14 11:10 ..</span><br><span class="line">-rwxr-xr-x   1 chris  chris    444 Aug 25  2013 backup</span><br><span class="line">-rwxr-xr-x   1 chris  chris    642 Jan 17 14:42 deploy</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;update&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="emoji绘文字"><a href="#emoji绘文字" class="headerlink" title="emoji绘文字"></a><code>emoji</code>绘文字</h3><p>本功能基于 <code>markdown-it-emoji</code> ，所有<a href="https://github.com/markdown-it/markdown-it-emoji/blob/master/lib/data/full.json">标签参考戳此</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:kissing_heart:</span><br><span class="line">:ring:</span><br><span class="line">:notes:</span><br></pre></td></tr></table></figure><p>:kissing_heart: :ring: :notes:</p><h3 id="effects文字特效"><a href="#effects文字特效" class="headerlink" title="effects文字特效"></a><code>effects</code>文字特效</h3><p>本功能基于 <code>markdown-it-ins</code> 、 <code>markdown-it-bracketed-spans</code> 和 <code>markdown-it-attrs</code></p><p>:::danger no-icon</p><p>本主题风格颜色通用样式：default、primary、success、info、warning、danger</p><p>:::</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">++下划线++</span><br><span class="line">++波浪线++&#123;.wavy&#125;</span><br><span class="line">++着重点++&#123;.dot&#125;</span><br><span class="line">++紫色下划线++&#123;.primary&#125;</span><br><span class="line">++绿色波浪线++&#123;.wavy .success&#125;</span><br><span class="line">++黄色着重点++&#123;.dot .warning&#125;</span><br><span class="line">~~删除线~~</span><br><span class="line">~~红色删除线~~&#123;.danger&#125;</span><br><span class="line">==荧光高亮==</span><br><span class="line">[赤橙黄绿青蓝紫]&#123;.rainbow&#125;</span><br><span class="line">[红色]&#123;.red&#125;</span><br><span class="line">[粉色]&#123;.pink&#125;</span><br><span class="line">[橙色]&#123;.orange&#125;</span><br><span class="line">[黄色]&#123;.yellow&#125;</span><br><span class="line">[绿色]&#123;.green&#125;</span><br><span class="line">[靛青]&#123;.aqua&#125;</span><br><span class="line">[蓝色]&#123;.blue&#125;</span><br><span class="line">[紫色]&#123;.purple&#125;</span><br><span class="line">[灰色]&#123;.grey&#125;</span><br><span class="line">快捷键 [Ctrl]&#123;.kbd&#125; + [C]&#123;.kbd .red&#125;</span><br><span class="line">H~2~0</span><br><span class="line">29^th^</span><br></pre></td></tr></table></figure><p>:::warning</p><p>这段代码因为自动被 pangu.js 处理了一下，加了几个空格，导致直接复制代码不能正常显示。</p><p>正确的代码是 <code>++下划线++</code> <code>~~删除线~~</code> <code>==荧光高亮==</code> ，不能有空格哦。</p><p>:::</p><p>++下划线++</p><p>++波浪线++{.wavy}</p><p>++着重点++{.dot}<br>++紫色下划线++{.primary}<br>++绿色波浪线++{.wavy .success}<br>++黄色着重点++{.dot .warning}<br><del>删除线</del><br><del>红色删除线</del>{.danger}<br>==荧光高亮==<br>[赤橙黄绿青蓝紫]{.rainbow}<br>[红色]{.red}<br>[粉色]{.pink}<br>[橙色]{.orange}<br>[黄色]{.yellow}<br>[绿色]{.green}<br>[靛青]{.aqua}<br>[蓝色]{.blue}<br>[紫色]{.purple}<br>[灰色]{.grey}<br>快捷键 [Ctrl]{.kbd} + [C]{.kbd .red}<br>H<del>2</del>0<br>29^th^</p><h3 id="spoiler隐藏文字"><a href="#spoiler隐藏文字" class="headerlink" title="spoiler隐藏文字"></a><code>spoiler</code>隐藏文字</h3><p>本功能基于 <code>markdown-it-spoiler</code> 和 <code>markdown-it-attrs</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!!黑幕黑幕黑幕黑幕黑幕黑幕!!：鼠标滑过显示内容</span><br><span class="line">!!模糊模糊模糊模糊模糊模糊!!&#123;.bulr&#125;： 选中文字显示内容</span><br></pre></td></tr></table></figure><p>!!123!!：鼠标滑过显示内容</p><p>!!模糊模糊模糊模糊模糊模糊!!{.bulr}： 选中文字显示内容</p><h3 id="label标签块"><a href="#label标签块" class="headerlink" title="label标签块"></a><code>label</code>标签块</h3><p>本功能基于 <code>markdown-it-bracketed-spans</code> 和 <code>markdown-it-attrs</code> 有以下颜色可选</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[default]&#123;.label&#125;</span><br><span class="line">[primary]&#123;.label .primary&#125;</span><br><span class="line">[info]&#123;.label .info&#125;</span><br><span class="line">[:heavy_check_mark:success]&#123;.label .success&#125;</span><br><span class="line">[warning]&#123;.label .warning&#125;</span><br><span class="line">[:broken_heart:danger]&#123;.label .danger&#125;</span><br></pre></td></tr></table></figure><p>[default]{.label}<br>[primary]{.label .primary}<br>[info]{.label .info}<br>[:heavy_check_mark:success]{.label .success}<br>[warning]{.label .warning}<br>[:broken_heart:danger]{.label .danger}</p><h3 id="note提醒块"><a href="#note提醒块" class="headerlink" title="note提醒块"></a><code>note</code>提醒块</h3><p>本功能基于 <code>markdown-it-container</code> </p><p>标签为：</p><table><thead><tr><th>位置</th><th>代码</th></tr></thead><tbody><tr><td>开始行</td><td><code>:::[风格颜色]</code></td></tr><tr><td>结束行</td><td><code>:::</code></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:::default</span><br><span class="line">默认默认</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">:::primary</span><br><span class="line">基本基本</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">:::info</span><br><span class="line">提示提示</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">:::success</span><br><span class="line">成功成功</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">:::warning</span><br><span class="line">警告警告</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">:::danger</span><br><span class="line">危险危险</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">:::danger no-icon</span><br><span class="line">没有图标</span><br><span class="line">:::</span><br></pre></td></tr></table></figure><p>:::default<br>默认默认<br>:::</p><p>:::primary<br>基本基本<br>:::</p><p>:::info<br>提示提示<br>:::</p><p>:::success<br>成功成功<br>:::</p><p>:::warning<br>警告警告<br>:::</p><p>:::danger<br>危险危险<br>:::</p><p>:::danger no-icon<br>没有图标<br>:::</p><h3 id="tab标签卡"><a href="#tab标签卡" class="headerlink" title="tab标签卡"></a><code>tab</code>标签卡</h3><p>本功能基于 <code>markdown-it-container</code> </p><p>标签为：</p><table><thead><tr><th>位置</th><th>代码</th></tr></thead><tbody><tr><td>开始行</td><td><code>;;;[同一ID] [标签名称]</code></td></tr><tr><td>结束行</td><td><code>;;;</code></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;;;id1 卡片 1</span><br><span class="line">这里是卡片 1 的内容</span><br><span class="line">**加粗**</span><br><span class="line">[success]&#123;.label .success&#125;</span><br><span class="line"></span><br><span class="line">&amp;#123;% links %&amp;#125;</span><br><span class="line">- site: 優萌初華</span><br><span class="line">  owner: 霜月琉璃</span><br><span class="line">  url: https://shoka.lostyu.me</span><br><span class="line">  desc: 琉璃的医学 &amp; 编程笔记</span><br><span class="line">  image: https://cdn.jsdelivr.net/gh/amehime/shoka@latest/images/avatar.jpg</span><br><span class="line">  color: &quot;#e9546b&quot;</span><br><span class="line">&amp;#123;% endlinks %&amp;#125;</span><br><span class="line">;;;</span><br><span class="line"></span><br><span class="line">;;;id1 卡片 2</span><br><span class="line">这里是卡片 2 的内容</span><br><span class="line">:::danger</span><br><span class="line">危险危险</span><br><span class="line">:::</span><br><span class="line">- 第一行</span><br><span class="line">- 第二行</span><br><span class="line">;;;</span><br><span class="line"></span><br><span class="line">;;;id2 ②号标签卡片 1</span><br><span class="line">这里是卡片 1 的内容</span><br><span class="line">;;;</span><br><span class="line"></span><br><span class="line">;;;id2 ②号标签卡片 2</span><br><span class="line">这里是卡片 2 的内容</span><br><span class="line">;;;</span><br></pre></td></tr></table></figure><p>;;;id1 卡片 1<br>这里是卡片 1 的内容<br><strong>加粗</strong><br>[success]{.label .success}</p><p>;;;id1 卡片 2<br>这里是卡片 2 的内容<br>:::danger<br>危险危险<br>:::</p><ul><li>第一行</li><li>第二行<br>;;;</li></ul><p>;;;id2 ②号标签卡片 1<br>这里是卡片 1 的内容<br>;;;</p><p>;;;id2 ②号标签卡片 2<br>这里是卡片 2 的内容<br>;;;</p><p>:bulb:：若遇见渲染问题，可看原博主blog下的评论</p><h3 id="collapse折叠块"><a href="#collapse折叠块" class="headerlink" title="collapse折叠块"></a><code>collapse</code>折叠块</h3><p>本功能基于 <code>markdown-it-container</code> </p><p>标签为：</p><table><thead><tr><th>位置</th><th>代码</th></tr></thead><tbody><tr><td>开始行</td><td><code>+++[风格颜色] [标题文字]</code></td></tr><tr><td>结束行</td><td><code>+++</code></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+++ 默认默认 这里是一段文字</span><br><span class="line">++下划线++</span><br><span class="line">+++</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+++primary 紫色</span><br><span class="line">:::info</span><br><span class="line">参考信息</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">- 第一行</span><br><span class="line">- 第二行</span><br><span class="line">+++</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+++info  蓝色</span><br><span class="line">;;;id3 卡片 1</span><br><span class="line">这里是卡片 1 的内容</span><br><span class="line">;;;</span><br><span class="line"></span><br><span class="line">;;;id3 卡片 2</span><br><span class="line">这里是卡片 2 的内容</span><br><span class="line">;;;</span><br><span class="line">+++</span><br><span class="line"></span><br><span class="line">+++success 绿色</span><br><span class="line">&#123;% links %&#125;</span><br><span class="line">- site: 優萌初華</span><br><span class="line">  url: https://shoka.lostyu.me</span><br><span class="line">  color: &quot;#e9546b&quot;</span><br><span class="line">&#123;% endlinks %&#125;</span><br><span class="line">+++</span><br><span class="line"></span><br><span class="line">+++warning 黄色</span><br><span class="line">!!警告警告警告警告警告!!&#123;.bulr&#125;</span><br><span class="line">[label]&#123;.label .success&#125;</span><br><span class="line">+++</span><br><span class="line"></span><br><span class="line">+++danger 红色</span><br><span class="line">[danger]&#123;.label .danger&#125;</span><br><span class="line">+++</span><br></pre></td></tr></table></figure><p>+++ 默认默认 这里是一段文字<br>++下划线++</p><p>+++</p><p>+++primary 紫色<br>:::info<br>参考信息<br>:::</p><ul><li>第一行</li><li>第二行</li></ul><p>+++</p><p>+++info  蓝色<br>;;;id3 卡片 1<br>这里是卡片 1 的内容<br>;;;</p><p>;;;id3 卡片 2<br>这里是卡片 2 的内容<br>;;;<br>+++</p><p>+++success 绿色hexo<br>+++</p><p>+++warning 黄色<br>!!警告警告警告警告警告!!{.bulr}<br>[label]{.label .success}</p><p>+++</p><p>+++danger 红色<br>[danger]{.label .danger}<br>+++</p><h3 id="taskList待办事项"><a href="#taskList待办事项" class="headerlink" title="taskList待办事项"></a><code>taskList</code>待办事项</h3><p>本功能基于 <code>markdown-it-task-checkbox</code> 。</p><p>可以利用 <code>markdown-it-attrs</code> 添加风格颜色，只可以给 <code>ul</code> 标签添加，需要新建两行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [ ] 这是一个小叉叉</span><br><span class="line">- [x] 这是一个红色勾勾</span><br><span class="line"></span><br><span class="line">&#123;.danger&#125;</span><br><span class="line"></span><br><span class="line">- [ ] 未完成</span><br><span class="line">- [x] 完成</span><br><span class="line"></span><br><span class="line">&#123;.primary&#125;</span><br><span class="line"></span><br><span class="line">- [ ] 未完成</span><br><span class="line">- [x] 默认颜色</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 这是一个小叉叉</li><li><input checked="" disabled="" type="checkbox"> 这是一个红色勾勾</li></ul><p>{.danger}</p><ul><li><input disabled="" type="checkbox"> 未完成</li><li><input checked="" disabled="" type="checkbox"> 完成</li></ul><p>{.primary}</p><ul><li><input disabled="" type="checkbox"> 未完成</li><li><input checked="" disabled="" type="checkbox"> 默认颜色</li></ul><h3 id="math数学公式"><a href="#math数学公式" class="headerlink" title="math数学公式"></a><code>math</code>数学公式</h3><p>本功能基于 <code>markdown-it-katex</code> </p><p>在 Front Matter 中添加 <code>math: true</code> 以支持 <a href="https://katex.org/">KaTex</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 数学公式显示</span><br><span class="line">math: true</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">行内公式：$\sqrt &#123;3x-1&#125;+(1+x)^2$</span><br><span class="line"></span><br><span class="line">独立块显示：</span><br><span class="line">$$\begin &#123;array&#125;&#123;c&#125;</span><br><span class="line"></span><br><span class="line">\nabla \times \vec &#123;\mathbf &#123;B&#125;&#125; -\, \frac1c\, \frac &#123;\partial\vec &#123;\mathbf &#123;E&#125;&#125;&#125;&#123;\partial t&#125; &amp;</span><br><span class="line">= \frac &#123;4\pi&#125;&#123;c&#125;\vec &#123;\mathbf &#123;j&#125;&#125;    \nabla \cdot \vec &#123;\mathbf &#123;E&#125;&#125; &amp; = 4 \pi \rho \\</span><br><span class="line"></span><br><span class="line">\nabla \times \vec &#123;\mathbf &#123;E&#125;&#125;\, +\, \frac1c\, \frac &#123;\partial\vec &#123;\mathbf &#123;B&#125;&#125;&#125;&#123;\partial t&#125; &amp; = \vec &#123;\mathbf &#123;0&#125;&#125; \\</span><br><span class="line"></span><br><span class="line">\nabla \cdot \vec &#123;\mathbf &#123;B&#125;&#125; &amp; = 0</span><br><span class="line"></span><br><span class="line">\end &#123;array&#125;$$</span><br></pre></td></tr></table></figure><p>行内公式：$\sqrt {3x-1}+(1+x)^2$ </p><p>独立块显示： </p><p>$$\begin {array}{c} </p><p>\nabla \times \vec {\mathbf {B}} -, \frac1c, \frac {\partial\vec {\mathbf {E}}}{\partial t} &amp; = \frac {4\pi}{c}\vec {\mathbf {j}}    \nabla \cdot \vec {\mathbf {E}} &amp; = 4 \pi \rho \</p><p>\nabla \times \vec {\mathbf {E}}, +, \frac1c, \frac {\partial\vec {\mathbf {B}}}{\partial t} &amp; = \vec {\mathbf {0}} \</p><p>\nabla \cdot \vec {\mathbf {B}} &amp; = 0</p><p>\end {array}$$</p><h3 id="mermaid流程图"><a href="#mermaid流程图" class="headerlink" title="mermaid流程图"></a><code>mermaid</code>流程图</h3><p>本功能基于 <code>markdown-it-mermaid</code> </p><p>在 Front Matter 中添加 <code>mermaid: true</code> 以支持 Mermaid</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 流程图显示</span><br><span class="line">mermaid: true</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">```Mermaid</span><br><span class="line">graph LR</span><br><span class="line">    A[Square Rect] -- Link text --&gt; B((Circle))</span><br><span class="line">    A --&gt; C(Round Rect)</span><br><span class="line">    B --&gt; D&#123;Rhombus&#125;</span><br><span class="line">    C --&gt; D</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```Mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">    loop Daily query</span><br><span class="line">        Alice-&gt;&gt;Bob: Hello Bob, how are you?</span><br><span class="line">        alt is sick</span><br><span class="line">            Bob-&gt;&gt;Alice: Not so good :(</span><br><span class="line">        else is well</span><br><span class="line">            Bob-&gt;&gt;Alice: Feeling fresh like a daisy</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        opt Extra response</span><br><span class="line">            Bob-&gt;&gt;Alice: Thanks for asking</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>:warning:第一个流程图的代码中，A、B、C、D与其后的括号之间均无空格</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Square Rect] -- Link text --&gt; B((Circle))</span><br><span class="line">    A --&gt; C(Round Rect)</span><br><span class="line">    B --&gt; D&#123;Rhombus&#125;</span><br><span class="line">    C --&gt; D</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    loop Daily query</span><br><span class="line">        Alice-&gt;&gt;Bob: Hello Bob, how are you?</span><br><span class="line">        alt is sick</span><br><span class="line">            Bob-&gt;&gt;Alice: Not so good :(</span><br><span class="line">        else is well</span><br><span class="line">            Bob-&gt;&gt;Alice: Feeling fresh like a daisy</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        opt Extra response</span><br><span class="line">            Bob-&gt;&gt;Alice: Thanks for asking</span><br><span class="line">        end</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h4 id="cat-流程图mermaid不能正常渲染解决方案"><a href="#cat-流程图mermaid不能正常渲染解决方案" class="headerlink" title=":cat:流程图mermaid不能正常渲染解决方案"></a>:cat:流程图mermaid不能正常渲染解决方案</h4><ol><li>打开<code>node_modules\hexo-renderer-multi-markdown-it\lib\renderer\markdown-it-mermaid</code>文件</li><li>在第61行的<code>if</code>语句前加一行：<code>console.log(token.info + &#39;&lt;------&#39; + (token.info === &#39;Mermaid&#39;))</code></li><li>将<code>if</code>语句判断条件中的<code>mermaid</code>改成大写<code>Mermaid</code></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">md.<span class="property">renderer</span>.<span class="property">rules</span>.<span class="property">fence</span> = <span class="function">(<span class="params">tokens, idx, options, env, self</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> token = tokens[idx]</span><br><span class="line">        <span class="keyword">const</span> code = token.<span class="property">content</span>.<span class="title function_">trim</span>()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(token.<span class="property">info</span> + <span class="string">&#x27;&lt;------&#x27;</span> + (token.<span class="property">info</span> === <span class="string">&#x27;Mermaid&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> (token.<span class="property">info</span> === <span class="string">&#x27;Mermaid&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> firstLine = code.<span class="title function_">split</span>(<span class="regexp">/\n/</span>)[<span class="number">0</span>].<span class="title function_">trim</span>()</span><br><span class="line">            <span class="keyword">if</span> (firstLine.<span class="title function_">match</span>(<span class="regexp">/^graph (?:TB|BT|RL|LR|TD);?$/</span>)) &#123;</span><br><span class="line">                firstLine = <span class="string">&#x27; graph&#x27;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                firstLine = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">mermaidChart</span>(code, config, firstLine)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">defaultRenderer</span>(tokens, idx, options, env, self)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>:warning:==在Typora编辑的时候Mermaid的第一个字母要大写==</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```Mermaid</span><br><span class="line">...</span><br><span class="line">```</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo主题Shoka使用说明 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/15/hello-world/"/>
      <url>/2022/10/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
